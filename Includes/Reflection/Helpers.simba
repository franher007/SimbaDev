{$include_once reflection/Reflection.simba}
procedure reinitializeReflection(forced: Boolean = false);
begin
  if forced or (currentBaseX <> RSCLient.BaseX) or (currentBaseY <> RSCLient.Basey) or (currentPlane <> RSCLient.plane) then
  begin
    WriteLnEx("Reinitialized reflection", true);
    RInitializeTileSettings;
    RInitializeTileHeights;

    //UpdateRegionCache(RSClient.BaseX, RSClient.BaseY, true);
    currentBaseX := RSCLient.BaseX;
    currentBaseY := RSCLient.basey;
    currentPlane := RSCLient.Plane;
  end;
end;

Function timerToTime(timer: Int32): String;
var
  totalSeconds, seconds, minutes, hours: Int32;
begin
  totalSeconds := timer div 1000;
  hours := totalSeconds div 3600;
  minutes := (totalSeconds - (3600 * hours)) div 60;
  seconds := totalSeconds - (minutes * 60) - (hours * 3600);
  if hours < 10 then
    Result := "0" + inttostr(hours)
  else Result := inttostr(hours);
  if minutes < 10 then
    Result += ":0" + inttostr(minutes)
  else Result += ":" + inttostr(minutes);
  if seconds < 10 then
    Result += ":0" + inttostr(seconds)
  else Result += ":" + inttostr(seconds);
end;

function debugTabulator(str:String):String
var
  i: integer;
begin
  for i:= 0 to (5 - length(str)) do Result += " ";
end;

Function MStoFormattedTime(M:Integer): String;
var
  hh,mm,ss: Integer;
begin
  ConvertTime(M, hh, mm, ss);
  Result := FormatDateTime('hh:nn:ss',EncodeTime(hh, mm, ss, 0));
end;


Function RSGroundItem.Midpoint: TPoint;
begin
  Result := self.Tile.TileToMS;
end;

Function RSObject.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function RSPlayer.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function RSNPC.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function TPoint.inMS: Boolean;
begin
  Result := self.InBox([0, 0, RSClient.ViewPortWidth, RSclient.ViewPortHeight]);
end;

Function PointinMS(point:TPoint): Boolean;
begin
  Result := point.InBox([0, 0, RSClient.ViewPortWidth, RSclient.ViewPortHeight]);
end;

Function RSNPC.inMS: Boolean;
var
  midpoint: TPoint;
begin
  midpoint := self.MidPoint;
  Result := midpoint.inMS;
end;

Function TRSInventoryItem.MidPoint: TPoint;
begin
  Result := self.Bounds.Middle;
end;

Function getSpiralTiles(playerX, playerY: Integer; Distance: integer = 0; Direction: Boolean = True): Array of TPoint;
var
  x, y, i, resultIndex: Integer;
begin
  resultIndex := ceil(pow((2*Distance+1),2))-1;
  x := 0;
  y := 0;
  for i := 0 to resultIndex do
  begin
    //writeln('('+inttostr(x)+','+inttostr(y)+'),');
    SetLength(Result,i+1);
    Result[i] := Point(PlayerX + X, PlayerY + Y);
    if Direction then
    begin
      if (abs(X) <= abs(Y)) and ((x <> y) or (x >= 0)) then
      begin
        if y >= 0 then
          x := x + 1
        else
          x := x - 1;
      end else
      begin
        if x >= 0 then
          y := y - 1
        else
          y := y + 1;
      end;
    end else
    begin
      if (abs(Y) <= abs(X)) and ((x <> y) or (Y >= 0)) then
      begin
        if x >= 0 then
          y := y + 1
        else
          y := y - 1;
      end else
      begin
        if y >= 0 then
          x := x - 1
        else
          x := x + 1;
      end;
    end;
  end;
end;

Function R_GetClosestGroundItemByID(ID: Integer; Offset: Integer = 10; upText: String = ""): RSGroundItem;
var
  X, Y, i, j, otIndex, otIndex2, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  allObjectsAtTile: Array of RSGroundItem;
  currentObject, currentObjectLeft: RSGroundItem;
  badUptext: Boolean;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  for i := 0 to High(Tiles) do
  begin
    badUptext := False;
    allObjectsAtTile := RSGroundObject.GetAll;
    writeln(allObjectsAtTile);
    for otIndex := 0 to high(allObjectsAtTile) do
    begin
      currentObject := allObjectsAtTile[otIndex];
      writeln(currentObject.ID);
      if currentObject.ID = ID then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          allObjectsAtTile := RSGroundObject.GetAll;
          for otIndex := 0 to high(allObjectsAtTile) do
          begin
            currentObjectLeft := allObjectsAtTile[otIndex];
            if currentObjectLeft.ID = ID then
            begin
              if upText <> "" then
              begin
                Mouse.Move(currentObjectLeft.MidPoint, 3);
                sleep(100 + random(100, 200));
                If not R_IsUpText([upText], false) then badUptext := True;
              end;
              if badUptext then Continue;
              distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
              break;
            end;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Function R_GetClosestObjectByName(Name: String; Offset: Integer = 10; upText: String = ""): RSObject;
var
  X, Y, i, j, otIndex, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  currentObject, currentObjectLeft: RSObject;
  badUptext: Boolean;
  objectTypes: Array of RSObjectType;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  objectTypes := [RSObjectType.GAME_OBJECT, RSObjectType.BOUNDARY_OBJECT, RSObjectType.FLOOR_DECORATION, RSObjectType.WALL_DECORATION];
  for otIndex := 0 to High(objectTypes) do
  begin
    for i := 0 to High(Tiles) do
    begin
      badUptext := False;
      currentObject := RSObject.Get(objectTypes[otIndex], Tiles[i].X, Tiles[i].Y);
      if currentObject.Definition.Name = Name then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          currentObjectLeft := RSObject.Get(objectTypes[otIndex], TilesLeft[j].X, TilesLeft[j].Y);
          if currentObjectLeft.Definition.Name = Name then
          begin
            if upText <> "" then
            begin
              Mouse.Move(currentObjectLeft.MidPoint, 3);
              sleep(100 + random(100, 200));
              if not R_IsUpText([upText], false) then badUptext := True;
            end;
            if badUptext then Continue;
            distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
            break;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          currentObjectLeft.Free;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          currentObject.Free;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Function R_GetClosestObjectByID(ID: Int32; Offset: Integer = 10; upText: String = ""): RSObject;
var
  X, Y, i, j, otIndex, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  currentObject, currentObjectLeft: RSObject;
  badUptext: Boolean;
  objectTypes: Array of RSObjectType;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  objectTypes := [RSObjectType.GAME_OBJECT, RSObjectType.BOUNDARY_OBJECT, RSObjectType.FLOOR_DECORATION, RSObjectType.WALL_DECORATION];
  for otIndex := 0 to High(objectTypes) do
  begin
    for i := 0 to High(Tiles) do
    begin
      badUptext := False;
      currentObject := RSObject.Get(objectTypes[otIndex], Tiles[i].X, Tiles[i].Y);
      if currentObject.Definition.ID = ID then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          currentObjectLeft := RSObject.Get(objectTypes[otIndex], TilesLeft[j].X, TilesLeft[j].Y);
          if currentObjectLeft.Definition.ID = ID then
          begin
            if upText <> "" then
            begin
              Mouse.Move(currentObjectLeft.MidPoint, 3);
              sleep(100 + random(100, 200));
              if not R_IsUpText([upText], false) then badUptext := True;
            end;
            if badUptext then Continue;
            distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
            break;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          currentObjectLeft.Free;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          currentObject.Free;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Procedure TMouse.Click(Middle: TPoint; action: String; Radius: Int32 = 0; Button: Int32 = 1); overload;
var
  i: integer;
begin
  for i := 0 to 5 do
    begin
      Mouse.Move(Middle, Radius, True);
      sleep(20);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(Button);
        Break;
      end;
    end;
end;

Procedure clickNPC(id: Integer; action: String = ""; walk: Boolean = True);
var
  gNPC: RSNPC;
  tries: integer;
begin
  gNPC := R_NPC_GetFirst(id);
  writelnex("Clicking NPC: " + gNPC.Definition.Name);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    if not gNPC.inMS then
      RSPlayer.Me.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  if (action <> "") then
  begin
    for tries := 0 to 5 do
    begin
      Mouse.Move(gNPC.MidPoint, 3);
      sleep(10);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(MOUSE_LEFT);
        Break;
      end;
    end;
  end else
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Procedure clickClosestNPC(id: Integer; action: String = ""; walk: Boolean = True);
var
  gNPC: RSNPC;
  tries: integer;
begin
  gNPC := R_NPC_GetClosest(id, 20);
  writelnex("Clicking NPC: " + gNPC.Definition.Name);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    if not gNPC.inMS then
      RSPlayer.Me.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  if (action <> "") then
  begin
    for tries := 0 to 5 do
    begin
      Mouse.Move(gNPC.MidPoint, 3);
      sleep(10);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(MOUSE_LEFT);
        Break;
      end;
    end;
  end else
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Procedure clickNPCUntilTalk(id: Integer; action: String = "");
var
  gNPC: RSNPC;
  tries, i: Integer;
begin
  gNPC := R_NPC_GetFirst(id);
  if gNPC.ref = nil then Exit;
  tries := 0;
  if not gNPC.inMS then
      RSPlayer.Me.WalkToTileMM(gNPC.Tile, 0, 0);
  sleep(2000 + random(100, 200));
  while (not R_IsClickToContinue) and (tries < 10) do
  begin
    if (action <> "") then
    begin
      for i := 0 to 5 do
      begin
        Mouse.Move(gNPC.MidPoint, 3);
        sleep(10);
        if R_IsUpText([action], false) then
        begin
          Mouse.Click(MOUSE_LEFT);
          Break;
        end;
      end;
    end else
      Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
  gNPC.Free;
end;

Procedure talkToNPC(option: String = "");
var
  tries: Integer;
begin
  R_ChatInput;
  while (R_IsClickToContinue or R_IsChatChooseOption) and (tries < 20) do
  begin
    SendKeys(" ", 0, 0);
    if R_IsChatChooseOption then SendKeys(option, 0, 0);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
end;

procedure ResMouseClick(X, Y, R: Integer; Button: Integer);
begin
    Mouse.Click(x + ((RSClient.ViewPortWidth - 765) div 2) + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R), Button);
end;
procedure ResMouseMove(X, Y: Integer; R: Integer = 0);
begin
    Mouse.Move(x + ((RSClient.ViewPortWidth - 765) div 2) + 5 + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R));
end;

Function TextMatches(a, b: String): Boolean;
begin
  Result := a = b;
end;

Function TextContains(substr, source: String): Boolean;
begin
  Result := pos(substr, source) > 0;
end;

function substring(const d, start, finish: String):String;
begin
  Result := Copy(d, pos(start, d) + length(start), pos(finish, d) - pos(start, d) - length(finish));
end;

Function isWidgetHidden(widget: RSWidget): Boolean;
begin
  Result := widget.IsHidden;
end;

//BAnk and GE

procedure condWait(Condition: Function:Boolean; timeout: integer; trueOrFalse: Boolean = true);
var
  timer: Timer;
begin
  timer.Start;
  if trueOrFalse then
  begin
    while (not Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end else
  begin
    while (Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end;
end;

function returnTrue:Boolean;
begin
  Result := true;
end;

function StrInArray(const Value : String;const ArrayOfString : Array of String) : Boolean;
var
 Loop : String;
begin
  for Loop in ArrayOfString do
  begin
    if Value = Loop then
    begin
       Exit(true);
    end;
  end;
  result := false;
end;
