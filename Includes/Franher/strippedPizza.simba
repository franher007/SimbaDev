{$include_once reflection/GrandExchange.simba}
{$include_once franher/shared.simba}

type
  TWebPlayer = record
  email, password, user, action, scriptId: String;
  active, online: Boolean;
  end;

type
  TWebScript = record
  action: String;
  ID, pizzaPrice, grainPrice, shrimpPrice, troutPrice, salmonPrice, hatPrice, potPrice, bucketPrice: Integer;
  end;

type
  TWebMessage = record
  name, message, target: String;
  combat: Integer;
  end;


var
  pizzasDone, runs, floursDone, fishesDone, geVisits              : Integer;
  cShrimps, cTrouts, cSalmons, cPots, cBuckets, cHats, cCoins     : Integer;
  totalCoins, totalPizzas, totalGrains, pizzasInGE, grainsInGE : Integer;
  timerTrack                        : Timer;
  timeSinceLastGeVisit              : Timer;
  CurrentSetTimer                   : Timer;
  CurrentAccountTimer               : Timer;
  CurrentSprintTimer                : Timer;
  CurrentSet                        : Integer;
  startTime                         : TDateTime;
  antibanMark                       : Timer;
  isMillEmpty                       : Boolean;
  player                            : RSPlayer;
  startPos                          : TPoint;
  pickWheat                         : Boolean;
  sellPizzas                        : Boolean;
  action                            : String;
  currentUser                       : String;
  currentPassword                   : String;
  currentGrainPrice                 : Integer;
  currentPizzaPrice                 : Integer;
  currentShrimpPrice                : Integer;
  currentTroutPrice                 : Integer;
  currentSalmonPrice                : Integer;
  currentHatPrice                   : Integer;
  currentPotPrice                   : Integer;
  currentBucketPrice                : Integer;
  webPlayer                         : TWebPlayer;
  webScript                         : TWebScript;
  grainsInBank                      : Integer;
  shouldRunOneOff                   : Boolean;
  tradeMode                         : Boolean;

  bmp: TMufasaBitmap;
  w, h: Int32;
  debugLines: TStringArray;
  //ScriptID: TStringArray;
  currentPlane, currentBaseX, currentBaseY : Integer;


procedure setupDrawing;
begin
  debugLines := ['','','','','',''];
  GetClientDimensions(W, H);
  EIOS_SetGraphicsDebugging(R_EIOS, True);

  Bmp.Init;
  Bmp.SetPersistentMemory(PtrUInt(EIOS_GetDebugImageBuffer(R_EIOS)), w, h);

  Bmp.Rectangle([0, 0, w - 1, h - 1], $00);
  client.GetMBitmaps().AddBMP(bmp);
end;

procedure TMufasaBitmap.DrawText(txt: String; pt: TPoint; Color: TColor); overload;
begin
  Self.DrawText(txt, 'StatChars07', pt, False, Color);
end;

procedure writeStatus(text:string);
var i, y: integer;
begin
  for i := 0 to high(debugLines)-1 do
  begin
    debugLines[i] := debugLines[i+1];
  end;
  debugLines[high(debugLines)] := text;

  for i := 0 to high(debugLines) do
  begin
    y := (i * 14) + 340;
    bmp.Rectangle([7, y, 494, y + 16], 9812684);
    bmp.DrawText("[" + FormatDateTime('hh:nn',now) + "]" + debugLines[i], Point(7, y), $11);
  end;
end;

Procedure writelnex(text: String; both: Boolean = False);
begin
  if both then writeln("["+tabID+"]" + text);
  try
    if useDebug then writeln("["+tabID+"]["+scriptID[currentSet]+"]["+player.name+"]: " + text) else writeStatus(text);
  Except
    if useDebug then writeln("["+tabID+"]["+scriptID[currentSet]+"]["+currentUser+"]: " + text) else writeStatus(text);
  end;
end;

procedure writeDebug(strings: TStringArray);
var
  i, y: integer;
begin
  for i := 0 to high(strings) do
  begin
    y := (i * 10) + 20;
    bmp.Rectangle([20, y, w - 1, y + 16], $00);
    bmp.DrawText(strings[i], Point(20, y), $FFFFFF);
  end;
end;

procedure reinitializeReflection(forced: Boolean = false);
begin
  if forced or (currentBaseX <> RSCLient.BaseX) or (currentBaseY <> RSCLient.Basey) or (currentPlane <> RSCLient.plane) then
  begin
    WriteLnEx("Reinitialized reflection", true);
    RInitializeTileSettings;
    RInitializeTileHeights;

    //UpdateRegionCache(RSClient.BaseX, RSClient.BaseY, true);
    currentBaseX := RSCLient.BaseX;
    currentBaseY := RSCLient.basey;
    currentPlane := RSCLient.Plane;
  end;
end;

Function timerToTime(timer: Int32): String;
var
  totalSeconds, seconds, minutes, hours: Int32;
begin
  totalSeconds := timer div 1000;
  hours := totalSeconds div 3600;
  minutes := (totalSeconds - (3600 * hours)) div 60;
  seconds := totalSeconds - (minutes * 60) - (hours * 3600);
  if hours < 10 then
    Result := "0" + inttostr(hours)
  else Result := inttostr(hours);
  if minutes < 10 then
    Result += ":0" + inttostr(minutes)
  else Result += ":" + inttostr(minutes);
  if seconds < 10 then
    Result += ":0" + inttostr(seconds)
  else Result += ":" + inttostr(seconds);
end;

function debugTabulator(str:String):String
var
  i: integer;
begin
  for i:= 0 to (5 - length(str)) do Result += " ";
end;

Function MStoFormattedTime(M:Integer): String;
var   
  hh,mm,ss: Integer;
begin
  ConvertTime(M, hh, mm, ss);
  Result := FormatDateTime('hh:nn:ss',EncodeTime(hh, mm, ss, 0));
end;

procedure ProgressReport;
var
  debugStrings: TStringArray;
begin
  if useDebug then
  begin
    writelnex('##########  PROGRESS  ##########');
    writelnex('## CURRENT TIME: ' + FormatDateTime('hh:nn:ss',now));
    writelnex('## Time Running: ' + FormatDateTime('hh:nn:ss',now-startTime));
    writelnex('## Set Runtime:  ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime));
    writelnex('## Account time: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime));
    writelnex('## Sprint time : ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime));
    writelnex('## RUNS        : ' + intToStr(runs));
    writelnex('## Flours      : ' + intToStr(floursDone));
    writelnex('## Pizzas      : ' + intToStr(pizzasDone));
    writelnex('## Fishes      : ' + intToStr(fishesDone));
    writelnex('## GE VISITS   : ' + intToStr(geVisits));
    writelnex('## -------  PER HOUR  ------- ##');
    writelnex('## RUNS        : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * runs)));
    writelnex('## Flours      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * floursDone)));
    writelnex('## Pizzas      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * pizzasDone)));
    writelnex('## Fishes      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * fishesDone)));
    writelnex('## GE visits   : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * geVisits)));
    writelnex('################################');
    writelnex('GTR: ' + inttostr(GetTimeRunning));
    writelnex('TSLGEV: ' + inttostr(TimeSinceLastGeVisit.ElapsedTime));
  end;
  debugStrings := [ CurrentUser + ': TabID: ' + TabID + ' - ScriptID: ' + scriptID[currentSet] + ' - Action: ' + action,
                    //'Time running: ' + FormatDateTime('dd:hh:nn:ss',now-startTime) + ' Set: ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime) + ' Acc: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime) + ' Sprint: ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime),
                    'Time running: ' + TimerToTime(timerTrack.ElapsedTime) + ' Set: ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime) + ' Acc: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime) + ' Sprint: ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime),
                    'Runs       : ' + intToStr(runs) + debugTabulator(intToStr(runs)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * runs)),
                    'Pizzas    : ' + intToStr(pizzasDone) + debugTabulator(intToStr(pizzasDone)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * pizzasDone)),
                    'Pizzas in bank: ' + intToStr(totalPizzas) + ' | Pizzas in GE: ' + intToStr(pizzasInGe),
                    'Grains in bank: ' + intToStr(totalGrains) + ' | Grains in GE: ' + intToStr(grainsInGe),
                    'Coins in bank: ' + intToStr(totalCoins),
                    'GE visits : ' + intToStr(geVisits) + debugTabulator(intToStr(geVisits)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * geVisits)),
                    'Time since last GE visit: ' +  inttostr(TimeSinceLastGeVisit.ElapsedTime div 1000 div 60)];
  writeDebug(debugStrings);
end;

Function RSGroundItem.Midpoint: TPoint;
begin
  Result := self.Tile.TileToMS;
end;

Function RSObject.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function RSPlayer.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function RSNPC.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function TPoint.inMS: Boolean;
begin
  Result := self.InBox([0, 0, RSClient.ViewPortWidth, RSclient.ViewPortHeight]);
end;

Function PointinMS(point:TPoint): Boolean;
begin
  Result := point.InBox([0, 0, RSClient.ViewPortWidth, RSclient.ViewPortHeight]);
end;

Function RSNPC.inMS: Boolean;
var
  midpoint: TPoint;
begin
  midpoint := self.MidPoint;
  Result := midpoint.inMS;
end;

Function TRSInventoryItem.MidPoint: TPoint;
begin
  Result := self.Bounds.Middle;
end;

function TileOnMM(Tile: RSTile; radius: integer = 0): Boolean;
var
  W, H, MMCX, MMCY: Int32;
  Temp: TPointArray;
begin
  GetClientDimensions(W, H);
  if RSClient.IsResizeable then
  begin
    MMCX := (W - 82);   //From RSTile.
    MMCY := 84;
  end else
    begin
      MMCX := (W - 122);
      MMCY := 84;
    end;

  SetLength(Temp, 1);
  Temp[0] := Tile.ToLocal.TileToMM;
  FilterPointsPie(Temp, 0.0, 360.0, 0.0, 76.0 - radius, MMCX, MMCY);
  Result := Length(Temp) = 1;
end;

{$IFNDEF CODEINSIGHT}
    {*Credit JuKKa*}
function WindPath(Xs, Ys, Xe, Ye, Gravity, Wind, MaxStep, TargetArea: Extended): TPointArray;
var
  VeloX, VeloY, WindX, WindY, VeloMag, Dist, RandomDist, LastDist: Extended;
  Step, Sqrt2, Sqrt3, Sqrt5: Extended;
  LastX, LastY: Integer;
begin
  Sqrt2:= Sqrt(2);
  Sqrt3:= Sqrt(3);
  Sqrt5:= Sqrt(5);
  while Hypot(Xs - Xe, Ys - Ye) > 1 do
  begin
    Dist:= hypot(Xs - Xe, Ys - Ye);
    Wind:= Min(Wind, Dist);
    if Dist >= TargetArea then
    begin
      WindX:= WindX / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
      WindY:= WindY / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
    end else
    begin
      WindX:= WindX / Sqrt2;
      WindY:= WindY / Sqrt2;
      if (MaxStep < 3) then
        MaxStep:= random(3) + 3.0
      else
        MaxStep:= MaxStep / Sqrt5;
    end;
    VeloX:= VeloX + WindX;
    VeloY:= VeloY + WindY;
    VeloX:= VeloX + Gravity * (Xe - Xs) / Dist;
    VeloY:= VeloY + Gravity * (Ye - Ys) / Dist;
    if Hypot(VeloX, VeloY) > MaxStep then
    begin
      RandomDist:= MaxStep / 2.0 + random(0, (round(MaxStep) div 2));
      VeloMag:= sqrt(VeloX * VeloX + VeloY * VeloY);
      VeloX:= (VeloX / VeloMag) * RandomDist;
      VeloY:= (VeloY / VeloMag) * RandomDist;
    end;
    LastX:= Round(Xs);
    LastY:= Round(Ys);
    Xs:= Xs + VeloX;
    Ys:= Ys + VeloY;
    SetArrayLength(Result, GetArrayLength(Result) + 1);
    Result[High(Result)] := Point(Round(Xs), Round(Ys));
    Step:= Hypot(Xs - LastX, Ys - LastY);
    LastDist:= Dist;
  end;
end;
{$ENDIF}

function RSPlayer.WalkToTileMM(Tile: RSTile; randomFrom: Integer = 0; randomTo: Integer = 0): Boolean;
var
  Point: TPoint;
begin
  Result := False;
  if not TileOnMM(Tile) then
  begin
    Exit;
  end;

  Point := Tile.ToLocal.TileToMM;
  Mouse.Move(Point.X + randomRange(randomFrom, randomTo), Point.Y + randomRange(randomFrom, randomTo));
  Wait(RandomRange(150, 220));
  Mouse.Click(MOUSE_LEFT);
  Result := True;
end;

function RSPlayer.WalkToTileMS(Tile: RSTile): Boolean;
var
  Point: TPoint;
begin
  Result := False;

  Point := Tile.ToLocal.TileToMS;
  Mouse.Move(Point);
  Wait(RandomRange(150, 220));
  Mouse.Click(MOUSE_LEFT);
  Result := True;
end;

function RSPlayer.FFlag(
  TileDist: Integer = 0; Timeout: Integer = -1): Boolean;
var
  Timer, StuckTimer: Int64;
  PrevTile, MyDest, MyTile : RSTile;
begin
  Timer := GetTickCount();
  StuckTimer := GetTickCount();

  MyTile := Self.Tile;
  PrevTile := MyTile;
  MyDest := Self.Destination;

  while Distance(MyTile.X, MyTile.Y, MyDest.X, MyDest.Y) > TileDist do
  begin
    if (Timeout > 0) and ((GetTickCount() - Timer) > Timeout) then
      Exit(False);

    if (GetTickCount() - StuckTimer) > 800 then
    begin
      if (MyTile.X = PrevTile.X) and (MyTile.Y = PrevTile.Y) then
        Exit(false);
      StuckTimer := GetTickCount();
      PrevTile := MyTile;
    end;

    Wait(RandomRange(200, 250));

    MyTile := Self.Tile;
    MyDest := Self.Destination;
  end;

  Exit(True);
end;

function Distance(const p1, p2: TPoint): Integer; overload;
begin
  Result := Distance(p1.x, p1.y, p2.x, p2.y);
end;

function RSPlayer.WalkPathMM(Path: array of RSTile; Randomness, FlagDist: Integer; Inverted: Boolean): Boolean;
var
  Index, Timer, Tries: Int64;
begin
  if Inverted then InvertTPA(Path);
  while Distance(Path[High(Path)], self.Tile) > (FlagDist + Randomness + 1) do
  begin
    for Index := High(Path) downto 0 do
      if TileOnMM(Path[Index]) then
        Break;
    if (Index = -1) then
      Break;
    Wait(800 + Random(100));
    if WalkToTileMM(Path[Index]) then
    begin
      Timer := (GetTickCount() + 5000);
      while Distance(Path[Index], self.Tile) > FlagDist do
      begin
        Wait(500 + Random(100));
        if Distance(Path[High(Path)], self.Tile) <= (FlagDist + Randomness + 1) then Break;
        if (GetTickCount() > Timer) or ((Index <> High(Path)) and (TileOnMM(Path[Index+1], 5))) then
          Break;
      end;
      if (GetTickCount() > Timer) then Inc(Tries);

      if (not (Distance(Path[Index], self.Tile) <= 5)) and ((Index <> High(Path)) and (not TileOnMM(Path[Index+1], 5))) then
      begin
        Inc(Tries);
      end;
    end else
    begin
      Inc(Tries);
      writelnEx('Tries: '+ inttostr(tries));
      wait(800+Random(600));
    end;
    if Tries >= 10 then Break;
  end;
  FFlag(FlagDist);
  Result := Distance(Path[High(Path)], self.Tile) <= (FlagDist + Randomness + 1);
end;

function RSPlayer.WalkToTileMSold(Tile: RSTile): Boolean;
begin
  Tile := Point(0, 0);
  {if not IsLoggedIn then
    Exit;
  Point := Reflect.Tiles.TileToMS(Tile);
  if (Point.X = -1) or (Point.Y = -1) then
    Exit;
  Reflect.Mouse.Move(Point, 0, 0);
  Wait(RandomRange(50, 100));
  if Reflect.Text.IsUpText('Walk here', 50) then
    Reflect.Mouse.Click(Mouse_Left)
  else
  begin
    Reflect.Mouse.Click(Mouse_Right);
    Wait(RandomRange(400, 500));
    if not Reflect.Text.ChooseOption('Walk here') then
      Reflect.Text.ChooseOption('Cancel')
  end;
  Timer.Start;
  while not Self.IsMoving do
  begin
    if Timer.ElapsedTime > 2500 then
      Break;
    Wait(150);
  end;
  Timer.Restart;
  while Self.IsMoving do
    Wait(250);
  Result := Timer.ElapsedTime < 30000; }
  Result := False;
end;

function RSPlayer.WalkTo(destination: String; precise: Boolean = False): Boolean;
var
  geToBankTiles, bankToCookTiles, cookToBankTiles, bankToGETiles, cookWaterSpot, cookExitSpot,
  lumbyToVarrock, bankToWild, wildToBank, wildToEast, bankToEast, eastToHouse, houseRange,
  houseDoorInside, houseToEast, eastToBank, bankToGrains, grainsToCook, grainExitSpot,
  grainEnterSpot, tToFish, tToFishGate, tToChef, tExitChef,
  tToQuest, ttoMiningInstructor, tToMiningGate, tToRats, tToBank, tToPrayer,
  tToMagic, wild0, wild4, wild8, wild12, wild16, wild20, wild24, choosenTile: Array of RSTile;
  tries: Integer;
begin
  geToBankTiles   := [Point(3165, 3483), Point(3165, 3486), Point(3166, 3471),
                      Point(3170, 3457), Point(3182, 3449),
                      Point(3183, 3445)];

  bankToCookTiles := [Point(3183, 3444), Point(3182, 3451),
                      Point(3173, 3452), Point(3165, 3451),
                      Point(3157, 3448), Point(3151, 3444),
                      Point(3146, 3441), Point(3143, 3442)];

  cookToBankTiles := [Point(3143, 3440), Point(3146, 3441),
                      Point(3151, 3444), Point(3157, 3448),
                      Point(3165, 3451), Point(3173, 3452),
                      Point(3182, 3451), Point(3183, 3444)];

  bankToGETiles   := [Point(3184, 3444), Point(3178, 3459),
                      Point(3166, 3460), Point(3166, 3468),
                      Point(3164, 3481), Point(3164, 3484)];

  cookWaterSpot   := [Point(3139, 3449)];

  cookExitSpot    := [Point(3143, 3446)];

  bankToWild      := [Point(3183, 3444), Point(3183, 3448),
                      Point(3189, 3448), Point(3196, 3448),
                      {Point(3202, 3442),} Point(3207, 3438),
                      Point(3213, 3435), Point(3220, 3430),
                      Point(3226, 3430), Point(3233, 3430),
                      Point(3239, 3430), Point(3246, 3430),
                      Point(3253, 3430), Point(3260, 3430),
                      Point(3266, 3430), Point(3274, 3431),
                      Point(3275, 3437), Point(3279, 3440),
                      Point(3282, 3447), Point(3286, 3453),
                      Point(3288, 3461), Point(3293, 3467),
                      Point(3295, 3473), Point(3299, 3479),
                      Point(3304, 3485), Point(3310, 3488),
                      Point(3315, 3491), Point(3320, 3498),
                      Point(3325, 3502), Point(3326, 3508),
                      Point(3326, 3516), Point(3323, 3520)];

  wildToBank      := [Point(3325, 3520),
                      Point(3325, 3517), Point(3326, 3511),
                      Point(3326, 3505), Point(3326, 3498),
                      Point(3321, 3494), Point(3317, 3492),
                      Point(3310, 3488), Point(3307, 3483),
                      Point(3301, 3479), Point(3297, 3473),
                      Point(3297, 3467), Point(3293, 3460),
                      Point(3286, 3453), Point(3286, 3447),
                      Point(3286, 3440), Point(3286, 3434),
                      Point(3280, 3429), Point(3275, 3428),
                      Point(3269, 3428), Point(3263, 3428),
                      Point(3256, 3428), Point(3250, 3428),
                      Point(3243, 3428), Point(3236, 3428),
                      Point(3230, 3428), Point(3222, 3428),
                      Point(3215, 3432), Point(3210, 3432),
                      Point(3205, 3438), Point(3199, 3438),
                      Point(3194, 3442), Point(3191, 3448),
                      Point(3184, 3448), Point(3183, 3445)];

    wildToEast      := [Point(3325, 3520),
                      Point(3325, 3517), Point(3326, 3511),
                      Point(3326, 3505), Point(3326, 3498),
                      Point(3321, 3494), Point(3317, 3492),
                      Point(3310, 3488), Point(3307, 3483),
                      Point(3301, 3479), Point(3297, 3473),
                      Point(3297, 3467), Point(3293, 3460),
                      Point(3286, 3453), Point(3286, 3447),
                      Point(3286, 3440), Point(3286, 3434),
                      Point(3280, 3429), Point(3275, 3428),
                      Point(3269, 3428), Point(3263, 3428),
                      Point(3256, 3428), Point(3252, 3427),
                      Point(3253, 3421), Point(3253, 3420)];

  lumbyToVarrock  := [Point(3222, 3218), Point(3227, 3218),
                      Point(3232, 3220), Point(3232, 3226),
                      Point(3232, 3232), Point(3234, 3239),
                      Point(3232, 3243), Point(3232, 3250),
                      Point(3231, 3256), Point(3229, 3261),
                      Point(3236, 3261), Point(3242, 3263),
                      Point(3243, 3270), Point(3241, 3277),
                      Point(3239, 3283), Point(3238, 3289),
                      Point(3238, 3295), Point(3238, 3301),
                      Point(3234, 3307), Point(3227, 3311),
                      Point(3225, 3317), Point(3221, 3323),
                      Point(3218, 3329), Point(3212, 3334),
                      Point(3206, 3341), Point(3204, 3346),
                      Point(3205, 3352), Point(3210, 3360),
                      Point(3211, 3366), Point(3211, 3373),
                      Point(3211, 3379), Point(3211, 3386),
                      Point(3211, 3393), Point(3211, 3399),
                      Point(3208, 3406), Point(3202, 3413),
                      Point(3200, 3419), Point(3196, 3425),
                      Point(3190, 3428), Point(3183, 3432),
                      Point(3183, 3439), Point(3183, 3441)];

  bankToEast      := [Point(3183, 3442),
                      Point(3183, 3436), Point(3185, 3432),
                      Point(3192, 3432), Point(3199, 3431),
                      Point(3206, 3429), Point(3212, 3429),
                      Point(3218, 3429), Point(3225, 3429),
                      Point(3232, 3429), Point(3238, 3429),
                      Point(3245, 3429), Point(3252, 3427),
                      Point(3253, 3421), Point(3253, 3420)];

   eastToHouse     := [Point(3253, 3420), Point(3253, 3424),
                       Point(3248, 3428), Point(3247, 3422),
                       Point(3245, 3416), Point(3242, 3412)];

   houseRange       := [Point(3238, 3410)];

   houseDoorInside  := [Point(3241, 3412)];

   houseToEast      := [Point(3241, 3412), Point(3242, 3414),
                        Point(3242, 3420), Point(3247, 3427),
                        Point(3253, 3426), Point(3254, 3420)];

   eastToBank       := [Point(3253, 3420), Point(3253, 3426),
                        Point(3247, 3428), Point(3241, 3428),
                        Point(3235, 3428), Point(3228, 3428),
                        Point(3221, 3428), Point(3215, 3432),
                        Point(3208, 3432), Point(3202, 3428),
                        Point(3196, 3428), Point(3190, 3428),
                        Point(3183, 3432), Point(3184, 3438)];

   tToFish          := [Point(3103, 3102), Point(3103, 3096)];

   tToFishGate      := [Point(3095, 3092), Point(3090, 3091)];

   tToChef          := [Point(3079, 3084)];

   tExitChef        := [Point(3073, 3090)];

   tToQuest         := [Point(3076, 3106),Point(3076, 3118),
                        Point(3086, 3126)];

   tToMiningInstructor  := [Point(3078, 9515),Point(3081, 9504)];

   tToMiningGate        := [Point(3094, 9502)];

   tToRats        := [Point(3111, 9518)];

   tToBank        := [Point(3122, 3123)];

   tToPrayer      := [Point(3133, 3115), Point(3125, 3107)];

   tToMagic       := [Point(3130, 3092), Point(3141, 3087)];

   grainEnterSpot  := [Point(3142, 3454)];

   grainExitSpot  := [Point(3142, 3460)];

   bankToGrains     := [Point(3181, 3451),
                        Point(3175, 3453), Point(3169, 3456),
                        Point(3163, 3456), Point(3156, 3456),
                        Point(3149, 3456), Point(3142, 3457)];

   grainsToCook     := [Point(3142, 3457),
                        Point(3137, 3452), Point(3137, 3446),
                        Point(3143, 3442)];

   wild4            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546)];

   wild8            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579)];

   wild12            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612)];

   wild16            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643)];

   wild20            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643), Point(3340, 3652),
                        Point(3340, 3661), Point(3340, 3669),
                        Point(3340, 3677)];

   wild24            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643), Point(3340, 3652),
                        Point(3340, 3661), Point(3340, 3669),
                        Point(3340, 3677), Point(3340, 3683),
                        Point(3340, 3692), Point(3340, 3701),
                        Point(3340, 3708)];

   wild0            := [Point(3340, 3708), Point(3340, 3701),
                        Point(3340, 3692), Point(3340, 3683),
                        Point(3340, 3677), Point(3340, 3669),
                        Point(3340, 3661), Point(3340, 3652),
                        Point(3339, 3643), Point(3334, 3635),
                        Point(3333, 3627), Point(3332, 3621),
                        Point(3332, 3612), Point(3336, 3605),
                        Point(3339, 3595), Point(3336, 3587),
                        Point(3335, 3579), Point(3333, 3571),
                        Point(3334, 3562), Point(3333, 3555),
                        Point(3331, 3546), Point(3330, 3539),
                        Point(3328, 3532), Point(3325, 3524)];

   case destination of
    "bankToCook": begin choosenTile := bankToCookTiles end;
    "geToBank": begin choosenTile := geToBankTiles end;
    "cookToBank": begin choosenTile := cookToBankTiles end;
    "bankToGe": begin choosenTile := bankToGETiles end;
    "cookWaterSpot": begin choosenTile := cookWaterSpot end;
    "cookExitSpot": begin choosenTile := cookExitSpot end;
    "lumbyToVarrock": begin choosenTile := lumbyToVarrock end;
    "bankToWild": begin choosenTile := bankToWild end;
    "wildToBank": begin choosenTile := wildToBank end;
    "bankToEast": begin choosenTile := bankToEast end;
    "eastToHouse": begin choosenTile := eastToHouse end;
    "houseRange": begin choosenTile := houseRange end;
    "houseDoorInside": begin choosenTile := houseDoorInside end;
    "houseToEast": begin choosenTile := houseToEast end;
    "eastToBank": begin choosenTile := eastToBank end;
    "tToFish": begin choosenTile := tToFish end;
    "tToFishGate": begin choosenTile := tToFishGate end;
    "tToChef": begin choosenTile := tToChef end;
    "tExitChef": begin choosenTile := tExitChef end;
    "tToQuest": begin choosenTile := tToQuest end;
    "tToMiningInstructor": begin choosenTile := tToMiningInstructor end;
    "tToMiningGate": begin choosenTile := tToMiningGate end;
    "tToRats": begin choosenTile := tToRats end;
    "tToBank": begin choosenTile := tToBank end;
    "tToPrayer": begin choosenTile := tToPrayer end;
    "tToMagic": begin choosenTile := tToMagic end;
    "bankToGrains": begin choosenTile := bankToGrains end;
    "grainsToCook": begin choosenTile := grainsToCook end;
    "grainExitSpot": begin choosenTile := grainExitSpot end;
    "grainEnterSpot": begin choosenTile := grainEnterSpot end;
    "wildToEast": begin choosenTile := wildToEast end;
    "wild0": begin choosenTile := wild0 end;
    "wild4": begin choosenTile := wild4 end;
    "wild8": begin choosenTile := wild8 end;
    "wild12": begin choosenTile := wild12 end;
    "wild16": begin choosenTile := wild16 end;
    "wild20": begin choosenTile := wild20 end;
    "wild24": begin choosenTile := wild24 end;
   end;

  reinitializeReflection;
  self.WalkPathMM(choosenTile, 0, 1, False);
  writelnex("endwalk " + destination);
  sleep(random(1200, 1600));
  reinitializeReflection(true);
  if not precise then Exit(True);
  tries := 0;
  while (self.Tile <> choosenTile[high(choosenTile)]) and (tries < 5) do
  begin
    writelnex('Final ' + destination + ' walk step');
    self.WalkToTileMS(choosenTile[high(choosenTile)]);
    Sleep(RandomRange(2000, 2500));
    inc(tries);
  end;
  reinitializeReflection(true);
  Result:=True;
end;

Function GetPageEx(page: String): String;
var
  response: String;
  tries: Integer;
begin
  response := "";
  tries := 0;
  while (response = "") and (tries < 10) do
  begin
    try
      tries := tries + 1;
      response := GetPage(page);
    Except
      WriteLnEx("Error getting page: " + page + ", retrying: " + inttostr(tries));
    End;
  end;
  Result := response;
end;

procedure SetPlayerOnline(name: String);
begin
  GetPageEx(actionWeb + "/enviar.php?setonlinebyname=" + name + "&coins=" + intToStr(totalCoins) + "&pizzasinbank=" + intToStr(totalPizzas) + "&pizzasinge=" + intToStr(pizzasInGE));
end;

procedure SetPlayerUsername(name, email: String);
begin
  GetPageEx(actionWeb + "/enviar.php?setusername=" + name + "&email=" + email);
end;

procedure SetPlayerBanned(email: String);
begin
  GetPageEx(actionWeb + "/enviar.php?setbanned=" + email);
end;

procedure SetBotWebMessage(name, message: String; combat: integer);
var
  response: String;
  tries: Integer;
begin
  response := GetPage(actionWeb + Replace("/enviar.php?setbotmessage=true&name=" + name + "&message=" + message + "&combat=" + IntToStr(combat), " ", "%20", [rfReplaceAll]));
  while Pos('nakedpizza', response) < 1 do
  begin
    sleep(1000);
    if tries > 10 then
      Exit;
    response := GetPage(actionWeb + Replace("/enviar.php?setbotmessage=true&name=" + name + "&message=" + message + "&combat=" + IntToStr(combat), " ", "%20", [rfReplaceAll]));
    inc(tries);
  end;
end;

procedure SetMuleWebMessage(name, message, target: String; combat: integer);
var
  response: String;
  tries: Integer;
begin
  GetPage(actionWeb + Replace("/enviar.php?setmulemessage=true&name=" + name + "&message=" + message + "&target=" + target + "&combat=" + IntToStr(combat), " ", "%20", [rfReplaceAll]));
  while Pos('nakedpizza', response) < 1 do
  begin
    if tries > 10 then
      Exit;
    response := GetPage(actionWeb + Replace("/enviar.php?setmulemessage=true&name=" + name + "&message=" + message + "&target=" + target + "&combat=" + IntToStr(combat), " ", "%20", [rfReplaceAll]));
    inc(tries);
  end;
end;

Function LoginPlayer:Boolean;
var
  tries: Integer;
  timer: Timer;
begin
  if (RSCLient.LoginState = 2) and (RSClient.GameState > 10) then
  begin
    SetPlayerOnline(RSPlayer.me.Name);
    Exit(True);
  end;         
  writelnEx("["+CurrentUser+"]Logging in: " + CurrentUser);
  tries := 0;
  while (RSClient.LoginState = 24) and (tries < 10) do
  begin
    Mouse.Click(400 + random(10), 310 + random(10), MOUSE_LEFT);
    wait(500 + random(100,200));
    inc(tries);
  end;

  tries := 0;
  while (RSClient.LoginState = 12) and (tries < 10) do
  begin
    Mouse.Click(380 + random(10), 320 + random(10), MOUSE_LEFT);
    wait(500 + random(100,200));
    inc(tries);
  end;

  tries := 0;
  while (RSClient.GameState > 10) or (RSClient.LoginState > 0) do
  begin
    PressKey(VK_ESCAPE);
    wait(500);                       //0,10 - 2,10 - 2,30 -
  end;
  if RSClient.LoginState = 0 then
  begin
    PressKey(13);
    wait(500 + random(100,200));
  end;
  if RSClient.LoginState = 2 then
  begin
    wait(500 + random(100,200));
    //for i:= 0 to 29 do
    //  PressKey(VK_BACK);
    SendKeys(CurrentUser, 0, 0);
    wait(200 + random(100,200));
    PressKey(13);
    //for i:= 0 to 29 do
    //  PressKey(VK_BACK);
    SendKeys(CurrentPassword, 0, 0);
    wait(100 + random(100,200));
    PressKey(13);
    wait(500 + random(100,200));
    timer.Start;
    while RSClient.GameState < 30 do
    begin
      if RSClient.LoginState = 12 then
      begin
        Mouse.Click(380, 320, MOUSE_LEFT);
        wait(500 + random(100,200));
        SetPlayerBanned(currentUser);
        Exit(false);
      end;
      if timer.ElapsedTime >= 20000 + lag then
        Exit(false);
      wait(300);
    end;
    timer.Reset;

    wait(1500 + random(200,500));
    Mouse.Click(400, 340, MOUSE_LEFT);
    wait(1500 + random(200,500));
    KeyDown(VK_UP);
    sleep(3000);
    KeyUp(VK_UP);
    reinitializeReflection;
    player := RSPlayer.Me;
    SetPlayerUsername(RSPlayer.me.Name, currentUser);
    sleep(500);
    SetPlayerOnline(RSPlayer.me.Name);
    Exit(True);
  end;
end;

Function LogoutPlayer: Boolean;
var
  widget: RSWidget;
begin
  writelnEx("["+CurrentUser+"]Logging out: " + CurrentUser);
  if not ((RSCLient.LoginState = 2) and (RSClient.GameState > 10)) then
    Exit(True);

  Mouse.Click(R_GameTabBounds(10), MOUSE_LEFT);
  sleep(random(500, 800));
  widget := RSWidget.Get(R_LOGOUT_BUTTON.Group, R_LOGOUT_BUTTON.Child);
  if widget.ref = nil then
    widget := RSWidget.Get(R_WORLD_SWITCHER_LOGOUT.Group, R_WORLD_SWITCHER_LOGOUT.Child);
  if widget.ref = nil then
    Exit(False);
  Mouse.Click(widget.bounds, MOUSE_LEFT);
  widget.Free;
  sleep(random(3000, 5000));
  if not ((RSCLient.LoginState = 2) and (RSClient.GameState > 10)) then
    Exit(True);
  Exit(False);
end;

Function RSPlayer.ToggleRun(run: boolean): Boolean;
var
  widget: RSWidget;
begin
  if run then
  begin
    if RSVarps.VarpMain(173) = 1 then Exit(True);
    widget := RSWidget.Get(R_INTERFACE_MINIMAP_ORB_RUN_ICON.Group, R_INTERFACE_MINIMAP_ORB_RUN_ICON.Child);
    Mouse.Click(widget.bounds, MOUSE_LEFT);
    widget.Free;
    Exit(True);
  end else
  begin
    if RSVarps.VarpMain(173) = 0 then Exit(True);
    widget := RSWidget.Get(R_INTERFACE_MINIMAP_ORB_RUN_ICON.Group, R_INTERFACE_MINIMAP_ORB_RUN_ICON.Child);
    Mouse.Click(widget.bounds, MOUSE_LEFT);
    widget.Free;
    Exit(True);
  end;
end;

Function RSPlayer.inGE: boolean;
begin
  Result := self.Tile.InBox(Box(3155, 3470, 3176, 3494));
end;

Function RSPlayer.inGrains: boolean;
begin
  Result := self.Tile.InBox(Box(3138, 3458, 3144, 3464));
end;

Function RSPlayer.inGuild: boolean;
begin
  Result := self.Tile.InBox(Box(3138, 3444, 3147, 3453));
end;

Function RSPlayer.inLumby: boolean;
begin
  Result := self.Tile.InBox(Box(3212, 3206, 3252, 3261));
end;

Function RSPlayer.inWestBank: boolean;
begin
  Result := self.Tile.InBox(Box(3180, 3433, 3190, 3447));
end;

Function RSPlayer.inEastBank: boolean;
begin
  Result := self.Tile.InBox(Box(3250, 3418, 3257, 3424));
end;

Function RSPlayer.inWildDitch: boolean;
begin
  Result := self.Tile.InBox(Box(3316, 3516, 3331, 3527));
end;

Function RT_inLumby: boolean;
begin
  Result := RSPlayer.Me.Tile.InBox(Box(3212, 3206, 3252, 3261));
end;

Function R_ChooseDisplayNameScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_TUTORIAL_CONTAINER.Group, R_TUTORIAL_CONTAINER.Child);
end;

Function R_ChooseCharacterScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_TUTORIAL_CHOOSE_ACCEPT_RES.Group, R_TUTORIAL_CHOOSE_ACCEPT_RES.Child);
end;

Function R_GetTutorialProgress: int32;
begin
  result := RSWidget.Get(R_TUTORIAL_PROGRESS.Group, R_TUTORIAL_PROGRESS.Child).Width;
end;

Function R_InTutorialIsland: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3050, 3050, 3200, 3135)) or RSPlayer.me.Tile.InBox(Box(3050, 8800, 3114, 9704));
end;

Function R_InNewTutorialIsland: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3050, 3050, 3200, 3135)) or RSPlayer.me.Tile.InBox(Box(3050, 8800, 3114, 9704));
end;

Function RT_InGielinorGuide: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3087, 3100, 3097, 3112));
end;

Function RT_InChef: Boolean;
begin
  Result := (RSPlayer.me.Tile.InBox(Box(3073, 3083, 3078, 3086))) or (RSPlayer.me.Tile.InBox(Box(3073, 3083, 3075, 3091))) or (RSPlayer.me.Tile.InBox(Box(3075, 3081, 3076, 3082)));
end;

Function RT_InQuest: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3082, 3119, 3089, 3125));
end;

Function getSpiralTiles(playerX, playerY: Integer; Distance: integer = 0; Direction: Boolean = True): Array of TPoint;
var
  x, y, i, resultIndex: Integer;
begin
  resultIndex := ceil(pow((2*Distance+1),2))-1;
  x := 0;
  y := 0;
  for i := 0 to resultIndex do
  begin
    //writeln('('+inttostr(x)+','+inttostr(y)+'),');
    SetLength(Result,i+1);
    Result[i] := Point(PlayerX + X, PlayerY + Y);
    if Direction then
    begin
      if (abs(X) <= abs(Y)) and ((x <> y) or (x >= 0)) then
      begin
        if y >= 0 then
          x := x + 1
        else
          x := x - 1;
      end else
      begin
        if x >= 0 then
          y := y - 1
        else
          y := y + 1;
      end;
    end else
    begin
      if (abs(Y) <= abs(X)) and ((x <> y) or (Y >= 0)) then
      begin
        if x >= 0 then
          y := y + 1
        else
          y := y - 1;
      end else
      begin
        if y >= 0 then
          x := x - 1
        else
          x := x + 1;
      end;
    end;
  end;
end;

Function R_GetClosestGroundItemByID(ID: Integer; Offset: Integer = 10; upText: String = ""): RSGroundItem;
var
  X, Y, i, j, otIndex, otIndex2, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  allObjectsAtTile: Array of RSGroundItem;
  currentObject, currentObjectLeft: RSGroundItem;
  badUptext: Boolean;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  for i := 0 to High(Tiles) do
  begin
    badUptext := False;
    allObjectsAtTile := RSGroundObject.GetAll;
    writeln(allObjectsAtTile);
    for otIndex := 0 to high(allObjectsAtTile) do
    begin
      currentObject := allObjectsAtTile[otIndex];
      writeln(currentObject.ID);
      if currentObject.ID = ID then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          allObjectsAtTile := RSGroundObject.GetAll;
          for otIndex := 0 to high(allObjectsAtTile) do
          begin
            currentObjectLeft := allObjectsAtTile[otIndex];
            if currentObjectLeft.ID = ID then
            begin
              if upText <> "" then
              begin
                Mouse.Move(currentObjectLeft.MidPoint, 3);
                sleep(100 + random(100, 200));
                If not R_IsUpText([upText], false) then badUptext := True;
              end;
              if badUptext then Continue;
              distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
              break;
            end;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Function R_GetClosestObjectByName(Name: String; Offset: Integer = 10; upText: String = ""): RSObject;
var
  X, Y, i, j, otIndex, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  currentObject, currentObjectLeft: RSObject;
  badUptext: Boolean;
  objectTypes: Array of RSObjectType;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  objectTypes := [RSObjectType.GAME_OBJECT, RSObjectType.BOUNDARY_OBJECT, RSObjectType.FLOOR_DECORATION, RSObjectType.WALL_DECORATION];
  for otIndex := 0 to High(objectTypes) do
  begin
    for i := 0 to High(Tiles) do
    begin
      badUptext := False;
      currentObject := RSObject.Get(objectTypes[otIndex], Tiles[i].X, Tiles[i].Y);
      if currentObject.Definition.Name = Name then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          currentObjectLeft := RSObject.Get(objectTypes[otIndex], TilesLeft[j].X, TilesLeft[j].Y);
          if currentObjectLeft.Definition.Name = Name then
          begin
            if upText <> "" then
            begin
              Mouse.Move(currentObjectLeft.MidPoint, 3);
              sleep(100 + random(100, 200));
              if not R_IsUpText([upText], false) then badUptext := True;
            end;
            if badUptext then Continue;
            distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
            break;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          currentObjectLeft.Free;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          currentObject.Free;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Function R_GetClosestObjectByID(ID: Int32; Offset: Integer = 10; upText: String = ""): RSObject;
var
  X, Y, i, j, otIndex, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  currentObject, currentObjectLeft: RSObject;
  badUptext: Boolean;
  objectTypes: Array of RSObjectType;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);
  objectTypes := [RSObjectType.GAME_OBJECT, RSObjectType.BOUNDARY_OBJECT, RSObjectType.FLOOR_DECORATION, RSObjectType.WALL_DECORATION];
  for otIndex := 0 to High(objectTypes) do
  begin
    for i := 0 to High(Tiles) do
    begin
      badUptext := False;
      currentObject := RSObject.Get(objectTypes[otIndex], Tiles[i].X, Tiles[i].Y);
      if currentObject.Definition.ID = ID then
      begin
        if upText <> "" then
        begin
          Mouse.Move(currentObject.MidPoint, 3);
          sleep(100 + random(100, 200));
          if not R_IsUpText([upText], false) then badUptext := True;
        end;
        if badUptext then Continue;
        distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
        for j := 0 to High(TilesLeft) do
        begin
          badUptext := False;
          currentObjectLeft := RSObject.Get(objectTypes[otIndex], TilesLeft[j].X, TilesLeft[j].Y);
          if currentObjectLeft.Definition.ID = ID then
          begin
            if upText <> "" then
            begin
              Mouse.Move(currentObjectLeft.MidPoint, 3);
              sleep(100 + random(100, 200));
              if not R_IsUpText([upText], false) then badUptext := True;
            end;
            if badUptext then Continue;
            distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
            break;
          end;
        end;
        if distanceLeft > distance then
        begin
          Result := currentObject;
          currentObjectLeft.Free;
          Exit;
        end else
        begin
          Result := currentObjectLeft;
          currentObject.Free;
          Exit;
        end;
        Break;
      end;
    end;
  end;
end;

Procedure TMouse.Click(Middle: TPoint; action: String; Radius: Int32 = 0; Button: Int32 = 1); overload;
var
  i: integer;
begin
  for i := 0 to 5 do
    begin
      Mouse.Move(Middle, Radius, True);
      sleep(20);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(Button);
        Break;
      end;
    end;
end;

Procedure clickNPC(id: Integer; action: String = ""; walk: Boolean = True);
var
  gNPC: RSNPC;
  tries: integer;
begin
  gNPC := R_NPC_GetFirst(id);
  writelnex("Clicking NPC: " + gNPC.Definition.Name);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    if not gNPC.inMS then
      player.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  if (action <> "") then
  begin
    for tries := 0 to 5 do
    begin
      Mouse.Move(gNPC.MidPoint, 3);
      sleep(10);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(MOUSE_LEFT);
        Break;
      end;
    end;
  end else
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Procedure clickClosestNPC(id: Integer; action: String = ""; walk: Boolean = True);
var
  gNPC: RSNPC;
  tries: integer;
begin
  gNPC := R_NPC_GetClosest(id, 20);
  writelnex("Clicking NPC: " + gNPC.Definition.Name);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    if not gNPC.inMS then
      player.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  if (action <> "") then
  begin
    for tries := 0 to 5 do
    begin
      Mouse.Move(gNPC.MidPoint, 3); 
      sleep(10);
      if R_IsUpText([action], false) then
      begin
        Mouse.Click(MOUSE_LEFT);
        Break;
      end;
    end;
  end else
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Function R_TradeNPC_IsOpen: Boolean;
begin
  Result := (RSWidget.IsValid(R_TRADE_SHOP_ITEMS.Group, R_TRADE_SHOP_ITEMS.Child));
end;

Function R_TradeNPC_Close: Boolean;
var
  Widget: RSWidget;
begin

  if not R_TradeNPC_IsOpen then
    Exit(True);

  Widget := RSWidget.Get(R_TRADE_SHOP_CLOSE.Group, R_TRADE_SHOP_CLOSE.Child, R_TRADE_SHOP_CLOSE.Index);

  if Widget.ref = nil then
    Exit(False);

  Mouse.Move(Widget.Bounds);
  Wait(50 + RandomRange(0, 50));
  Mouse.Click(MOUSE_LEFT);
  Widget.Free;
  Result := True;
end;

Function buyShopItem(name: String; amount: Integer; minAmountOnShop: Integer): boolean;
var
  shopItems: Array of RSWidget;
  i: integer;
begin
  if not (R_TradeNPC_IsOpen) then Exit;
  shopItems := RSWidget.Get(R_TRADE_SHOP_ITEMS.Group, R_TRADE_SHOP_ITEMS.Child).Children;
  for i := 0 to high(shopItems) do
  begin
    if (shopItems[i].Name = name) and (shopItems[i].ItemAmount >= minAmountOnShop) then
    begin
      Mouse.Click(shopItems[i].Bounds.Middle, 3, MOUSE_RIGHT);
      sleep(random(200, 500));
      if R_ChooseOptions([inttostr(amount)], false) then
      begin
        sleep(Random(300,500));
        Exit(True);
      end;
    end;
  end;
end;

Procedure tradeNPC(id: Integer; action: String = ""; walk: Boolean = True);
var
  gNPC: RSNPC;
  tries: integer;
  widget: RSWidget;
begin
  gNPC := R_NPC_GetFirst(id);
  writelnex("Trading NPC: " + gNPC.Definition.Name);
  if (RSWidget.IsValid(R_TRADE_SHOP_ITEMS.Group, R_TRADE_SHOP_ITEMS.Child)) then Exit;
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    if not gNPC.inMS then
      player.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  if (action <> "") then
  begin
    for tries := 0 to 5 do
    begin
      Mouse.Move(0, 0);
      sleep(random(100,200));
      Mouse.Click(gNPC.MidPoint, 5, MOUSE_RIGHT);
      sleep(Random(100,200));
      if R_ChooseOptions(['rade'], false) then
      begin
        sleep(Random(300,500));
        Exit;
      end;
    end;
  end else
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;


Procedure clickNPCUntilTalk(id: Integer; action: String = "");
var
  gNPC: RSNPC;
  tries, i: Integer;
begin
  gNPC := R_NPC_GetFirst(id);
  if gNPC.ref = nil then Exit;
  tries := 0;
  if not gNPC.inMS then
      player.WalkToTileMM(gNPC.Tile, 0, 0);
  sleep(2000 + random(100, 200));
  while (not R_IsClickToContinue) and (tries < 10) do
  begin
    if (action <> "") then
    begin
      for i := 0 to 5 do
      begin
        Mouse.Move(gNPC.MidPoint, 3);  
        sleep(10);
        if R_IsUpText([action], false) then
        begin
          Mouse.Click(MOUSE_LEFT);
          Break;
        end;
      end;
    end else
      Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
  gNPC.Free;
end;

Procedure talkToNPC(option: String = "");
var
  tries: Integer;
begin
  R_ChatInput;
  while (R_IsClickToContinue or R_IsChatChooseOption) and (tries < 20) do
  begin
    SendKeys(" ", 0, 0);
    if R_IsChatChooseOption then SendKeys(option, 0, 0);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
end;

procedure ResMouseClick(X, Y, R: Integer; Button: Integer);
begin
    Mouse.Click(x + ((RSClient.ViewPortWidth - 765) div 2) + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R), Button);
end;
procedure ResMouseMove(X, Y: Integer; R: Integer = 0);
begin
    Mouse.Move(x + ((RSClient.ViewPortWidth - 765) div 2) + 5 + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R));
end;

Function TextMatches(a, b: String): Boolean;
begin
  Result := a = b;
end;

Function TextContains(substr, source: String): Boolean;
begin
  Result := pos(substr, source) > 0;
end;

function substring(const d, start, finish: String):String;
begin
  Result := Copy(d, pos(start, d) + length(start), pos(finish, d) - pos(start, d) - length(finish));
end;

Function isWidgetHidden(widget: RSWidget): Boolean;
begin
  Result := widget.IsHidden;
end;

Function isSuggestedNameHiddenn: Boolean;
begin
  Result := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Group, R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Child).IsHidden;
end;

function isNameAvailable: Boolean;
begin
  Result := TextContains("reat", RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_AVAILABLE.Group, R_TUTORIAL_CHOOSE_NAME_AVAILABLE.Child).Text);
end;

procedure condWait(Condition: Function:Boolean; timeout: integer; trueOrFalse: Boolean = true);
var
  timer: Timer;
begin
  timer.Start;
  if trueOrFalse then
  begin
    while (not Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end else
  begin
    while (Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end;
end;

function returnTrue:Boolean;
begin
  Result := true;
end;

Function openClosestBank(name: String = "Bank booth"; offset: Integer = 10; upText: String = "Bank"): Boolean;
var
  bankBooth: RSObject;
  tries: Integer;
  bankHelp: RSWidget;
begin
  tries := 0;
  while (not R_BankScreen) do
  begin
    inc(tries);
    writelnex("Opening bank");
    bankBooth := R_GetClosestObjectByName(name, offset, upText);
    if (tries > 15) then
    begin
      writelnex("Bank not found");
      bankBooth.Free;
      Exit(False);
    end;
    if bankBooth.ref <> nil then
    begin
      Mouse.Click(bankBooth.MidPoint, 3, MOUSE_LEFT);
      condWait(@R_BankScreen, 5000, true);
    end;
    bankbooth.Free;
  end;
  tries := 0;
  sleep(300);
  while R_BankHelp do
  begin
    if (tries > 15) then Exit;
    writelnex("Closing Help");
    bankHelp := RSWidget.Get(R_BANK_HELP_CLOSE.Group, R_BANK_HELP_CLOSE.Child);
    if bankHelp.ref = nil then
    begin
      bankHelp.Free;
      Exit;
    end;
    Mouse.Click(bankHelp.Bounds.Middle, 5, MOUSE_LEFT);
    condWait(@R_BankHelp, 5000, false); 
    inc(tries);
    bankHelp.Free;
  end;
  Result := True;
  sleep(random(1500,1800));
end;

Function openClosestExchange: Boolean;
var
  exchangeBooth: RSObject;
  tries: Integer;
begin
  tries := 0;
  while not R_GrandExchangeScreen do
  begin
    inc(tries);
    writelnex("Opening GE");
    exchangeBooth := R_GetClosestObjectByName("Grand Exchange booth", 10, "Exchange Grand");
    if (tries > 15) then
    begin
      writelnex("GE not found");
      exchangeBooth.Free;
      Exit(False);
    end;
    if exchangeBooth.ref <> nil then
    begin
      Mouse.Click(exchangeBooth.MidPoint, 3, MOUSE_LEFT);
      condWait(@R_GrandExchangeScreen, 5000, true);
    end;
    exchangeBooth.Free;
  end;
  Result := True;   
  sleep(random(1500,1800));
end;

procedure sellCancelAndCollect(itemName: String;itemID, price:Integer);
begin
  writelnex('Selling ' + itemName + ' for ' + inttostr(price));
  if not openClosestExchange then Exit;
  //cancel current offer and collect
  if R_GrandExchange_EmptyItem(itemName) then sleep(random(1200,1400));;
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));

  //SELL STUFF
  R_GrandExchange_Sell(itemID, TRSOfferQuantity.ALL, 1, TRSOfferPrice.X, price);
  sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(700,1000));
end;

procedure buyCancelAndCollect(itemName: String;quantity, price:Integer);
begin
  writelnex('Buying ' + inttostr(quantity) + " " + itemName + ' for ' + inttostr(price));
  if not openClosestExchange then Exit;
  //cancel current offer and collect
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));
  if R_GrandExchange_EmptyItem(itemName) then sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));

  //BUY STUFF
  R_GrandExchange_Buy(itemName, TRSOfferQuantity.X, quantity, TRSOfferPrice.X, price);
  sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(700,1000));
end;

procedure countGrandExchangeItems;
begin
  if not openClosestExchange then Exit;
  pizzasInGE := R_GrandExchange_CountItem("Pizza base");
  grainsInGe := R_GrandExchange_CountItem("Grain");
end;

Function TutorialState: int32;
begin
  Result := RSVarps.VarpMain(281);
end;

Function R_TutorialIsland(name: String = ""): Boolean;
var
  widget: RSWidget;
  genericObject: RSObject;
  i, j, tries: Integer;
  attributes: array of RWidget;
Begin
  if not R_InTutorialIsland then Exit(False);
  //if not R_ChooseDisplaypizzasInGENameScreen then Exit(False);

  reinitializeReflection;

  while R_ChooseDisplayNameScreen do
  begin
    widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_FIELD.Group, R_TUTORIAL_CHOOSE_NAME_FIELD.Child);
    if widget.ref <> nil then
    begin
      //ResMouseClick(widget.Bounds.Middle.x + 10, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
      Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
      widget.Free;
      sleep(500 + random(500,700));
      if name <> "" then
      begin
        SendKeys(Copy(name, 0, pos("@", name))+"rsacc", 0, 0);
        wait(100 + random(100,200));
        PressKey(13);

        //sleep(3500 + random(500,700));
      end else
      begin
        SendKeys("a",0,0);
        PressKey(13);
        widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Group, R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Child);
        if not isSuggestedNameHiddenn then
          sleep(1500);
        condWait(@isSuggestedNameHiddenn, 10000, false);
        //ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
        Mouse.Click(widget.Bounds.Middle, 7, MOUSE_LEFT);
      end;
      condWait(@isNameAvailable, 10000, true);
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SET.Group, R_TUTORIAL_CHOOSE_NAME_SET.Child);
      //ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
      Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
      sleep(50+random(60,100));
      condWait(@R_ChooseDisplayNameScreen, 10000, false);
      widget.Free;
    end;
  end;
                                  
  SetPlayerUsername(RSPlayer.me.Name, currentUser);
  SetPlayerOnline(RSPlayer.me.Name);

  //PICK CHAR
  while R_ChooseCharacterScreen do
  begin

    attributes := [R_TUTORIAL_CHOOSE_HAIR, R_TUTORIAL_CHOOSE_HEAD,
                 R_TUTORIAL_CHOOSE_JAW, R_TUTORIAL_CHOOSE_TORSO,
                 R_TUTORIAL_CHOOSE_ARMS, R_TUTORIAL_CHOOSE_HANDS,
                 R_TUTORIAL_CHOOSE_LEGS, R_TUTORIAL_CHOOSE_FEET,
                 R_TUTORIAL_CHOOSE_LEGS_COLOR, R_TUTORIAL_CHOOSE_TORSO_COLOR,
                 R_TUTORIAL_CHOOSE_FEET_COLOR, R_TUTORIAL_CHOOSE_SKIN_COLOR];
    if random(0,1) = 1 then
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_MALE.Group, R_TUTORIAL_CHOOSE_MALE.Child)
    else
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_FEMALE.Group, R_TUTORIAL_CHOOSE_FEMALE.Child);
    //ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
    Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);

    //sleep(2500 + random(500,700));
    for i := 0 to High(attributes) do
    begin
      widget := RSWidget.Get(attributes[i].Group, attributes[i].Child);
      for j := 0 to random(4) do
      begin
        //ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
        Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
        //sleep(100);
      end;
    end;


    widget := RSWidget.Get(R_TUTORIAL_CHOOSE_ACCEPT_RES.Group, R_TUTORIAL_CHOOSE_ACCEPT_RES.Child);
    //ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
    Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
    widget.free;
    condWait(@R_ChooseCharacterScreen, 10000, false);
  end;


  //Talk to Guide  3308
  writeln('varp');
  writeln(RSVarps.VarpMain(281));

  while (RT_InGielinorGuide) do
  begin
    writeln('1');
    while (TutorialState = 2) do
    begin
      writeln('2');
      clickNPCuntilTalk(3308, "Gielinor Guide");
      talkToNPC("2");
      sleep(300);
    end;
    writeln('3');
    //Click llave inglesa
    while (TutorialState = 3) do
    begin
      if RSClient.IsResizeable then
      begin
        widget := RSWidget.Get(R_GAMETAB_RESIZEABLE_SETTINGS.Group, R_GAMETAB_RESIZEABLE_SETTINGS.Child);
        Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
        sleep(1000 + random(100,300));
        widget := RSWidget.Get(R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Group, R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Child, R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Index);
        Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
        widget.free;
        condWait(@RSClient.IsResizeable, 5000, false);
        sleep(300 + random(100, 200));
        bmp.Free;

        GetClientDimensions(W, H);
        EIOS_SetGraphicsDebugging(R_EIOS, True);

        Bmp.Init;
        Bmp.SetPersistentMemory(PtrUInt(EIOS_GetDebugImageBuffer(R_EIOS)), w, h);

        Bmp.Rectangle([0, 0, w - 1, h - 1], $00);
        client.GetMBitmaps().AddBMP(bmp);
      end else
      Mouse.Click(R_GameTabBounds(11), MOUSE_LEFT);  //open settings tab


      //SET ROOFS AND BRIGHTNESS
      //Mouse.Click(660, 400, MOUSE_LEFT);
      //sleep(2000 + random(100, 200));
      //Mouse.Click(190, 155, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      Mouse.Click(705, 305, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      //mute Music
      Mouse.Click(620, 220, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      Mouse.Click(603, 275, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      Mouse.Click(603, 320, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      Mouse.Click(603, 370, MOUSE_LEFT);
      sleep(300);
    end;

    while (TutorialState = 7) do
    begin
      clickNPCuntilTalk(3308, "Gielinor Guide");
      talkToNPC("2");
      sleep(300);
    end;

    //getOutOfGuide

    reinitializeReflection;
    while (TutorialState = 10) do
    begin
      writeln('4');
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3098, 3107);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      while RT_InGielinorGuide do
      begin
        Mouse.Click(genericObject.MidPoint, "Door" , 5, MOUSE_LEFT);
        sleep(1000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
      genericObject.Free;
      sleep(100);
    end;
  end;                      


  //GO FISH
  while (R_GetTutorialProgress = 31) do
  begin
    while (TutorialState = 20) do
    begin
      player.WalkTo("tToFish");
      sleep(1500+random(200,300));
      clickNPCuntilTalk(8503, "Survival Expert");
      clickNPC(3317, "Fishing spot");
      sleep(100);
    end;

    while (TutorialState = 30) do
    begin
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);
      sleep(100 + random(100, 200));
    end;

    //FISH
    while (TutorialState = 40) do
    begin
      clickNPC(3317, "Fishing spot", false);
      while R_CountInventoryItem(2514) < 1 do Sleep(100);
    end;

    while (TutorialState = 50) do
    begin
      Mouse.Click(R_GameTabBounds(1), MOUSE_LEFT);
      sleep(100 + random(100, 200));
    end;

    //Talk to Survival Expert
    while (TutorialState = 60) do
    begin
      clickNPCuntilTalk(8503, "Survival Expert");
      talkToNPC("2");
      sleep(100);
    end;
  end;

  //GO WC
  while (R_GetTutorialProgress = 47) do
  begin
    //Woodcut
    while (TutorialState = 70) do
    begin
      while R_CountInventoryItem(2511) < 1 do
      begin
        genericObject := RSObject.Get(RSObjectType.GAME_OBJECT, 3099, 3095);
        Mouse.Click(genericObject.MidPoint, "Tree", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(1000);
        while player.IsAnimating do sleep(100);
      end;
      sleep(100);
    end;
    //Fire
    while (TutorialState = 80) do
    begin
      player.WalkTo("tToFishGate", true);
      sleep(1500 + random(100, 200));
      player.walkToTileMM(player.Tile, -2, 2);
      Mouse.Click(R_GetInventoryItem(590)[0].Bounds, MOUSE_LEFT);
      sleep(100);
      Mouse.Click(R_GetInventoryItem(2511)[0].Bounds, MOUSE_LEFT);
      sleep(1000);
      while player.IsAnimating do sleep(100 + random(50,100));
      sleep(1000);
    end;

    //CookFish
    while (TutorialState = 90) do
    begin
      if R_CountInventoryItem(2514) > 0 then
      begin
        Mouse.Click(R_GetInventoryItem(2514)[0].Bounds, MOUSE_LEFT);
        sleep(200);
        genericObject := R_GetClosestObjectByName("Fire", 5);
        Mouse.Click(genericObject.MidPoint, "Fire", 5 , MOUSE_LEFT);
        //writeln(genericObject.Tile);
        genericObject.Free;
      end;
      while R_CountInventoryItem(315) < 1 do sleep(100);
    end;

    //OpenGateAndGoToChef  
    while (TutorialState = 120) do
    begin
      while player.Tile.X > 3089 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3089, 3091);
        Mouse.Click(genericObject.MidPoint, "Gate", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  //GoToChef
  while (R_GetTutorialProgress = 63) do
  begin    
    while (TutorialState = 130) do
    begin
      while not RT_InChef do
      begin
        player.WalkTo("tToChef");
        sleep(1500);
        while not RT_InChef do
        begin
          genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3079, 3084);
          Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
          genericObject.Free;
          sleep(2000 + random(100, 200));
          while player.IsAnimating do sleep(100);
        end;
      end;
      sleep(1000);
    end;

    //TalkToChef   
    while (TutorialState = 140) do
    begin
      ClickNPCUntilTalk(3305, "Master Chef");
      while R_CountInventoryItem(2516) < 1 do
      begin
        SendKeys(" ", 0, 0);
        if R_IsChatChooseOption then SendKeys("2", 0, 0);
        sleep(1000 + random(100, 200));
      end;
      sleep(100);
    end;

    //Mix Flwater  
    while (TutorialState = 150) do
    begin
      Mouse.Click(R_GetInventoryItem(2516)[0].Bounds, MOUSE_LEFT);
      sleep(100);
      Mouse.Click(R_GetInventoryItem(1929)[0].Bounds, MOUSE_LEFT);
      while R_CountInventoryItem(2307) < 1 do sleep(100);
    end;

    //cookBread         
    while (TutorialState = 160) do
    begin
      tries := 0;
      while (R_CountInventoryItem(2309) < 1) and (tries < 5) do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3075, 3081);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Range", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(4000);
        while player.IsAnimating do sleep(100);
        inc(tries)
      end;
    end;
  end;

  //ExitChef
  while (R_GetTutorialProgress = 80) do
  begin
    while (TutorialState = 170) do
    begin
      player.WalkTo("tExitChef");
      sleep(500);
      while player.IsAnimating do sleep(100);
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3072, 3090);
      while RT_InChef do
      begin
        Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
        sleep(2000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
      genericObject.Free;
      //sleep(1500);
    end;
  end;

  //WalkToQuest
  while (R_GetTutorialProgress = 95) do
  begin
    while (TutorialState = 200) do
    begin
      player.WalkTo("tToQuest");
      sleep(2000);
      tries := 0;
      while (not RT_InQuest) and (tries < 10) do
      begin
        inc(tries);
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3086, 3126);
        Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;
  sleep(1000);


  //TalkToQuest
  while (R_GetTutorialProgress = 111) do
  begin
    while (TutorialState = 220) do
    begin
      ClickNPCUntilTalk(3312, "Quest Guide");
      talkToNpc(" ");
      sleep(100);
    end;

    while (TutorialState = 230) do
    begin
      Mouse.Click(R_GameTabBounds(2), MOUSE_LEFT);  //open quests tab
      sleep(100 + random(100, 200));
    end;

    while (TutorialState = 240) do
    begin
      ClickNPCUntilTalk(3312, "Quest Guide");
      talkToNpc(" ");
      //send one more spacebar
      SendKeys(" ", 0, 0);
      sleep(1000 + random(100, 200));
      talkToNpc(" ");
    end;

    while (TutorialState = 250) do
    begin
      while player.Tile.Y < 9020 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3088, 3119);
        player.WalkToTileMM(genericObject.Tile, 0, 0);
        sleep(3000 + random(100, 200));
        Mouse.Click(genericObject.MidPoint, "Ladder", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  reinitializeReflection;

  //walkToMiningInstructor
  while (R_GetTutorialProgress = 127) do
  begin
    while (TutorialState = 260) do
    begin
      player.WalkTo("tToMiningInstructor");
      ClickNPCUntilTalk(3311, "Mining Instructor");
      talkToNpc(" ");
    end;

    //MineTin
    while (TutorialState = 270) or (TutorialState = 300) do
    begin
      while R_CountInventoryItem(438) < 1 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3077, 9504);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Rocks", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;

    //mineCopper
    while (TutorialState = 310) do
    begin
      while R_CountInventoryItem(436) < 1 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3083, 9501);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Rocks", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  //smeltItem
  while (R_GetTutorialProgress = 143) do
  begin
    while (TutorialState = 320) do
    begin
      while R_CountInventoryItem(2349) < 1 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3078, 9495);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Furnace", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;

    //walkToMiningInstructor
    while (TutorialState = 330) do
    begin
      //player.WalkTo("tToMiningInstructor");
      ClickNPCUntilTalk(3311, "Mining Instructor");
      talkToNpc(" ");
    end;

    //clickAnvil
    while (TutorialState = 340) do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3083, 9499);
      if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(4000 + random(100, 200));
        end;
      widget := RSWidget.Get(R_TUTORIAL_SMITHING_DAGGER.Group, R_TUTORIAL_SMITHING_DAGGER.Child, R_TUTORIAL_SMITHING_DAGGER.Index);
      while widget.ref = nil do
      begin
        Mouse.Click(genericObject.MidPoint, "Anvil", 5, MOUSE_LEFT);
        sleep(1500);
        while player.IsAnimating do sleep(100);
        widget := RSWidget.Get(R_TUTORIAL_SMITHING_DAGGER.Group, R_TUTORIAL_SMITHING_DAGGER.Child, R_TUTORIAL_SMITHING_DAGGER.Index);
      end;
    end;

    while (TutorialState = 350) do
    begin
      Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
      widget.Free;
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;

    //GoToGate
    while (TutorialState = 360) do
    begin
      player.WalkTo("tToMiningGate");
      sleep(1000 + random(100, 200));
      while player.Tile.X < 3095 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3094, 9502);
        Mouse.Click(genericObject.MidPoint, "Gate", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(2000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  //goToCombat
  while (R_GetTutorialProgress = 160) do
  begin          
    while (TutorialState = 370) do
    begin
      ClickNPCUntilTalk(3307, "Combat Instructor");
      talkToNpc(" ");
    end;

    while (TutorialState = 390) do
    begin
      Mouse.Click(R_GameTabBounds(4), MOUSE_LEFT);  //open equipment tab
      sleep(300 + random(100, 200));
    end;

    while (TutorialState = 400) do
    begin
      Mouse.Click(580, 430, MOUSE_LEFT);
      sleep(1000 + random(100, 200));
    end;

    while (TutorialState = 405) do
    begin
      player.WalkToTileMM(player.Tile, 3);
      ClickNPCUntilTalk(3307, "Combat Instructor");
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(1000 + random(100, 200));
      Mouse.Click(R_GetInventoryItem(1205)[0].Bounds, MOUSE_LEFT);
      sleep(1000 + random(100, 200));
    end;

    while (TutorialState = 410) do
    begin
      ClickNPCUntilTalk(3307, "Combat Instructor");
      talkToNpc(" ");
    end;

    while (TutorialState = 420) do
    begin
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(1000 + random(100, 200));
      if High(R_GetInventoryItem(1277)) >= 0 then
        Mouse.Click(R_GetInventoryItem(1277)[0].Bounds, MOUSE_LEFT);
      sleep(100 + random(100, 200));
      if High(R_GetInventoryItem(1171)) >= 0 then
        Mouse.Click(R_GetInventoryItem(1171)[0].Bounds, MOUSE_LEFT);
      sleep(1000 + random(100, 200));
    end;

    while (TutorialState = 430) do
    begin
      Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);  //open combat tab
      sleep(1000 + random(100, 200));
    end;
  end;

  //WalkToRats
  while (R_GetTutorialProgress = 175) do
  begin      
    while (TutorialState = 440) do
    begin
      player.WalkTo("tToRats");
      while player.Tile.X > 3110 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3111, 9518);
        Mouse.Click(genericObject.MidPoint, "Gate", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
      sleep(100);
    end;

    //killRat    
    while (TutorialState = 450) or (TutorialState = 460) do
    begin
      ClickClosestNPC(3313, "Rat");
      tries := 0;
      while (TutorialState <> 470) and (tries < 30) do
      begin
        sleep(1000+random(200,300));
        inc(tries);
      end;
    end;

    while (TutorialState = 470) do
    begin
      player.WalkTo("tToRats");
      while player.Tile.X < 3111 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3111, 9518);
        Mouse.Click(genericObject.MidPoint, "Gate", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
      ClickNPCUntilTalk(3307, "Combat Instructor");
      talkToNpc(" ");
    end;

    while (TutorialState = 480) and (R_GetTutorialProgress = 175) do
    begin
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open inventory tab
      sleep(500+random(200,300));
      Mouse.Click(R_GetInventoryItem(841)[0].Bounds, MOUSE_LEFT);
      sleep(200 + random(100, 200));
      Mouse.Click(R_GetInventoryItem(882)[0].Bounds, MOUSE_LEFT);
      sleep(1000 + random(100, 200));
    end;
  end;

  //killRat
  while (R_GetTutorialProgress = 191) do
  begin                 
    while (TutorialState = 480) or (TutorialState = 490) do
    begin
      player.WalkTo("tToRats");
      ClickClosestNPC(3313, "Rat", false);
      tries := 0;
      while (TutorialState <> 500) and (tries < 30) do
      begin
        sleep(1000+random(200,300));
        inc(tries);
      end;
    end;
        
    while (TutorialState = 500) do
    begin
      tries := 0;
      while (player.Tile.Y > 9020) and (tries < 10) do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3111, 9526);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(2000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Ladder", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
        inc(tries);
      end;
    end;
  end;

  //goBank
  reinitializeReflection;
  while (R_GetTutorialProgress = 223) do
  begin     
    while (TutorialState = 510) do
    begin
      player.WalkTo("tToBank");
      while not R_BankScreen do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3122, 3124);
        Mouse.Click(genericObject.MidPoint, "Bank", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(1000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;

    while (TutorialState = 520) do
    begin
      while not R_IsClickToContinue do
      begin
        genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3119, 3121);
        //es el poll, hay que caminar bro
        player.WalkToTileMM(genericObject.Tile, 0, 0);
        sleep(3000 + random(100, 200));
        Mouse.Click(genericObject.MidPoint, "Poll booth", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
      talkToNpc(" ");
      SendKeys(" ", 0, 0);
      sleep(800 + random(100,200));
    end;

    //openFirstBankDoor 
    while (TutorialState = 525) do
    begin
      while player.Tile.X < 3125 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3125, 3124);
        //first bank creo que tmb hay que caminar
        player.WalkToTileMM(genericObject.Tile, 0, 0);
        sleep(3000 + random(100, 200));
        Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(2000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  while (R_GetTutorialProgress = 240) do
  begin                 
    while (TutorialState = 530) do
    begin
      ClickNPCUntilTalk(3310, "Account Guide");
      talkToNpc(" ");
    end;

    while (TutorialState = 531) do
    begin
      Mouse.Click(R_GameTabBounds(8), MOUSE_LEFT);  //open account tab
      sleep(500+random(200,300));
    end;

    while (TutorialState = 532) do
    begin
      ClickNPCUntilTalk(3310, "Account Guide");
      talkToNpc(" ");
    end;

    //openSecondBankDoor  
    while (TutorialState = 540) do
    begin
      while player.Tile.X < 3130 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3130, 3124);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  //goPRay
  while (R_GetTutorialProgress = 255) do
  begin          
    while (TutorialState = 550) do
    begin
      player.WalkTo("tToPrayer");
      ClickNPCUntilTalk(3319, "Brother Brace");
      talkToNpc(" ");
    end;             
    while (TutorialState = 560) do
    begin
      Mouse.Click(R_GameTabBounds(5), MOUSE_LEFT);  //open prayer tab
      sleep(500+random(200,300));
    end;                  
    while (TutorialState = 570) do
    begin
      ClickNPCUntilTalk(3319, "Brother Brace");
      talkToNpc(" ");
    end;            
    while (TutorialState = 580) do
    begin
      Mouse.Click(R_GameTabBounds(9), MOUSE_LEFT);  //open friends tab
      sleep(500+random(200,300));
    end;              
    while (TutorialState = 600) do
    begin
      ClickNPCUntilTalk(3319, "Brother Brace");
      talkToNpc(" ");
    end;
  end;

  //openPRayerDoor
  while (R_GetTutorialProgress = 271) do
  begin        
    while (TutorialState = 610) do
    begin
      while player.Tile.Y > 3102 do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3122, 3102);
        if not PointInMS(genericObject.MidPoint) then
        begin
          player.WalkToTileMM(genericObject.Tile, 0, 0);
          sleep(3000 + random(100, 200));
        end;
        Mouse.Click(genericObject.MidPoint, "Door", 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(3000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
  end;

  //goMagic
  while (R_GetTutorialProgress = 287) do
  begin         
    while (TutorialState = 620) do
    begin
      player.WalkTo("tToMagic");
      reinitializeReflection;
      ClickNPCUntilTalk(3309, "Magic Instructor");
      talkToNpc(" ");
    end;           
    while (TutorialState = 630) do
    begin
      Mouse.Click(R_GameTabBounds(6), MOUSE_LEFT);  //open magic tab
      sleep(500+random(200,300));
    end;                      
    while (TutorialState = 640) do
    begin
      ClickNPCUntilTalk(3309, "Magic Instructor");
      talkToNpc(" ");
    end;
  end;         

  //kill chickenlittle
  while (R_GetTutorialProgress = 320) do
  begin         
    while (TutorialState = 650) do
    begin
      player.WalkToTileMM(Point(3140, 3091), 0, 1);
      sleep(3000 + random(100, 200));
      tries := 0;
      while not player.IsAnimating and (tries < 5) do
      begin
        Mouse.Click(615, 225, MOUSE_LEFT);
        sleep(100 + random(100,200));
        ClickClosestNPC(3316, "Chicken", false);
        sleep(300 + random(100,200));
        inc(tries);
      end;
    end;

    while (TutorialState = 670) do
    begin
      ClickNPCUntilTalk(3309, "Magic Instructor");
      SendKeys(" ", 0, 0);
      sleep(2000+random(200,300));
      SendKeys("1", 0, 0);
      sleep(2000+random(200,300));
      talkToNpc("3");
      SendKeys(" ", 0, 0);
      condWait(@RT_inLumby, 10000, true);
    end;
  end;
  //SET ROOFS AND BRIGHTNESS
  sleep(1500 + random(200,500));    

  talkToNpc(" ");
  player.WalkToTileMM(Point(3234, 3220), 1, 8);
  sleep(1000 + random(200,500));

  SendKeys("::toggleroofs", 0, 0);
  PressKey(13);
end;


procedure withdrawCoins;
begin
  if not openClosestBank("Grand Exchange booth", 10, "Bank Grand") then Exit;
  R_WithdrawItem(coinsID);
end;     

Function shouldSleep(minutes: int32): boolean;
begin
   Result := (CurrentSprintTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

Function shouldChangeAccount(minutes: int32): boolean;
begin
   Result := (CurrentAccountTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

Function shouldChangeSet(minutes: int32): boolean;
begin
   Result := (CurrentSetTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

procedure SleepAndPrintProgressReport(milis:Uint32);
var
  i: Integer;
begin
  for i := 0 to milis div 1000 do
  begin
    ProgressReport;
    sleep(1000);
  end;
  ProgressReport;
  sleep(milis mod 1000);
end;

procedure AntibanAndBreak(break:boolean = true);
var
  i, breakTotalMinutes, breakTotalSeconds, Chance, x, y: Integer;
begin
  if not LoginPlayer then Exit;

  if break and shouldSleep(accountPlayBeforeBreakMinutes + Random(-randomAccountPlayBeforeBreakMinutes, randomAccountPlayBeforeBreakMinutes)) then
  begin
    breakTotalMinutes := breakMinutes + Random(-randomBreakMinutes, randomBreakMinutes);
    breakTotalSeconds := breakTotalMinutes * 60;
    writelnEx('Been running for ' + IntToStr(CurrentSprintTimer.ElapsedTime div 1000 div 60) + ' minutes, taking a ' + IntToStr(breakTotalMinutes) + ' mins sleep');
    LogoutPlayer;
    sleepAndPrintProgressReport(breakTotalMinutes * 60 * 1000);
    LoginPlayer;
    currentSprintTimer.Reset;
    currentSprintTimer.Start;
  end;
  if (antiBanMark.ElapsedTime < (60000 + Random(30000))) then Exit;
  Chance := Random(40) + 1;
  WritelnEx('Antiban chance: ' + inttostr(Chance));
  case (Chance) of
    1:  begin
          WriteLnEx('Antiban 1');
          GetClientDimensions(x, y);
          Mouse.Move(Random(x), Random(y));
          Wait(200 + random(100));
          if (R_IsUpText(['ption'])) then
          begin
            Mouse.Click(MOUSE_RIGHT);
            Wait(200 + random(100));
            R_ChooseOptions(['xamine']);
          end;
          Wait(1000 + Random(500));
        end;
    2:  begin
          if (Random(5) = 1) then
          begin
            WriteLnEx('Antiban 2');
            Mouse.Click(R_GameTabBounds(1), MOUSE_LEFT);
            sleep(500 + random(100, 200));
            Mouse.Move(Random(550, 730), Random(250, 500));
            sleep(1000 + random(100, 200));
            Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);
            sleep(200 + random(100, 200));
          end;
        end;
    3:  begin
          if (Random(5) = 1) then
          begin
            WriteLnEx('Antiban 3');
            Mouse.Click(R_GameTabBounds(1), MOUSE_LEFT);
            sleep(500 + random(100, 200));
            Mouse.Move(Random(670, 730), Random(347, 369));
            sleep(1000 + random(100, 200));
            Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);
            sleep(200 + random(100, 200));
          end;
        end;
    4:  begin
          if (R_InventoryCount < 1) then Exit;
          Mouse.Click(R_GetInventorySlotItem(Random(1,R_InventoryCount)-1).Bounds, MOUSE_RIGHT);
          Wait(200 + random(100));
          R_ChooseOptions(['xamine']);
          Wait(1000 + Random(500));
        end;
    5:  begin
          WriteLnEx('Antiban 5');
          Mouse.Click(R_GameTabBounds(Random(13)), MOUSE_LEFT);
          sleep(500 + random(100, 200));
          Mouse.Move(Random(550, 730), Random(250, 500));
          sleep(1000 + random(100, 200));
          Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);
          sleep(200 + random(100, 200));
          Wait(500 + Random(500));
        end;
    6:  begin
          WriteLnEx('Antiban 6');
          GetClientDimensions(x, y);
          Mouse.Move(Random(x), Random(y));
          Wait(200 + random(100));
        end;
    7:  begin
          GetMousePos(x, y);
          Mouse.Move(x - Random(10), y - Random(10));
          Wait(200 + random(100));
        end;
    8:  begin
          WriteLnEx('Antiban 8');
          GetMousePos(x, y);
          Mouse.Move(x - Random(10), y - Random(10));
          sleep(Random(500));
          GetMousePos(x, y);
          Mouse.Move(x - Random(10), y - Random(10));
          sleep(Random(500));
          GetMousePos(x, y);
          Mouse.Move(x - Random(10), y - Random(10));
          sleep(Random(500));
        end;
    9: begin
          WriteLnEx('Antiban 9');
          SleepAndPrintProgressReport(Random(3000, 15000));
       end;
    10: begin
          if Random(3) <> 2 then Exit;
          WriteLnEx('Antiban 10');
          SleepAndPrintProgressReport(Random(6000, 30000));
       end;
    11: begin
          if Random(6) <> 3 then Exit;
          WriteLnEx('Antiban 11');
          SleepAndPrintProgressReport(Random(10000, 60000));
        end;
    12: begin
          player.ToggleRun(True);
        end;
    13: begin
          player.ToggleRun(False);
        end;

    else Exit;
  end;
  antibanMark.Reset;
  antibanMark.Start;
end;

procedure checkCurrentResources(bankName: String = "Grand Exchange booth"; upText: String = "Bank Grand");
begin
  if not openClosestBank(bankName, 10, upText) then Exit;

  cShrimps  := R_FindBankItem(rawShrimpID).Amount  + R_CountInventoryItem(rawShrimpID);
  cTrouts   := R_FindBankItem(rawTroutID).Amount   + R_CountInventoryItem(rawTroutID);
  cSalmons  := R_FindBankItem(rawSalmonID).Amount  + R_CountInventoryItem(rawSalmonID);
  cHats     := R_FindBankItem(chefHatID).Amount    + R_CountInventoryItem(chefHatID);
  cBuckets  := R_FindBankItem(bucketID).Amount     + R_CountInventoryItem(bucketID);
  cPots     := R_FindBankItem(potID).Amount        + R_CountInventoryItem(potID);
  try
    cCoins    := R_FindBankItem(coinsID).Amount      + R_GetInventoryItem(coinsID)[0].Amount;
  Except
    cCoins    := R_FindBankItem(coinsID).Amount;
  end;

  if cShrimps = -1 then cShrimps  := 0;
  if cTrouts  = -1 then cTrouts   := 0;
  if cSalmons = -1 then cSalmons  := 0;
  if cHats    = -1 then cHats     := 0;
  if cBuckets = -1 then cBuckets  := 0;
  if cPots    = -1 then cPots     := 0;
  if cCoins   = -1 then cCoins    := 0;
end;

procedure withdrawGrandExchangeItems(buyGrains, sellPizzas: boolean);
begin
  openClosestBank("Grand Exchange booth", 10, "Bank Grand");

  R_DepositAll_Items;
  sleep(random(850,1050));
  if buyGrains then R_WithdrawItem(coinsID);
  sleep(random(1500,1850));
  if sellPizzas then
  begin
    R_SetBankWithdrawMode(True);
    sleep(random(50,150));
    R_WithdrawItem(pizzaBaseID);
    sleep(random(550,750));
    R_SetBankWithdrawMode(False);
  end;
  R_BankScreen_Close;
end;

procedure withdrawWildItems;
begin
  writelnex("Opening bank");
  if not openClosestBank("Grand Exchange booth", 10, "Bank Grand") then Exit;

  R_DepositAll_Items;
  sleep(random(50,150));
  R_DepositAll_Equipment;
  sleep(random(1550,1850));
  R_WithdrawItem(coinsID);
  sleep(random(550,850));
  R_BankScreen_Close;
end;

procedure depositGrains;
begin
  writelnex("Opening bank");
 if not openClosestBank then Exit;

  R_DepositAll_Items;
  sleep(random(1050,1350));
  R_WithdrawItem(coinsID);
  R_BankScreen_Close;
end;

procedure withdrawFlourToPizzaItems;
var
  currentPizzaBases: Integer;
  emptyPot, emptyBucket, grain, chefHat: TRSBankItem;
  chefHatInv: Array of TRSInventoryItem;
begin
  currentPizzaBases := R_CountInventoryItem(pizzaBaseID);
  pizzasDone += currentPizzaBases;

  writelnex("Opening bank");

  if not openClosestBank then Exit;

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(1200, 1500));
  totalPizzas := R_FindBankItem(pizzaBaseID).Amount;
  totalCoins := R_FindBankItem(coinsID).Amount;
  totalGrains := R_FindBankItem(grainID).Amount;

  emptyPot := R_FindBankItem(potID);
  grain := R_FindBankItem(grainID);
  emptyBucket := R_FindBankItem(bucketID);

  if (grain.id = -1) then
    pickWheat := True
  else
    pickWheat := False;

  grainsInBank := grain.Amount;

  if ((emptyPot.id = -1)) or ((emptyBucket.id = -1)) then
  begin
    writelnex("missing flourToPizza items (pot or bucket), TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  sleep(random(500,700));
  R_WithdrawItem(emptyPot.ID, 1);
  sleep(random(150,150));
  R_WithdrawItem(emptyBucket.ID, 1);
  sleep(random(150,150));
  if not R_IsEquipped(chefHatID) then
  begin
    chefHat := R_FindBankItem(chefHatID);
    if ((chefHat.id = -1)) then
    begin
      writeLnEx("Hat not equipped and not in bank, F");
      TerminateScript;
    end;
    R_WithdrawItem(chefHat.ID, 1);
    sleep(random(150,150));
  end;
  if isMillEmpty then
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 26)
  end else
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 10);
  end;
  sleep(random(350,150));
  R_BankScreen_Close;
  sleep(random(1000,1250));
  if not R_IsEquipped(chefHatID) then
  begin
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
    sleep(1000 + random(100, 200));
    chefHatInv := R_GetInventoryItem(chefHatID);
    if length(chefHatInv) > 0 then
      Mouse.Click(chefHatinv[0].midpoint, 2, MOUSE_LEFT)
    else
    begin
      writeLnEx("Hat not equipped and not in inv, F");
      TerminateScript;
    end;
    sleep(random(600,850));
  end;
end;

procedure cookFish;
var
  julietRange: RSObject;
  currentFishID, currentCookingLevel: Integer;
  timer: Timer;
begin
  julietRange := RSObject.Get(RSObjectType.GAME_OBJECT, 3238, 3409);
  if (julietRange.ref = nil) then
  begin
    writelnex("Range not found");
    julietRange.Free;
    Exit;
  end;
  player.walkTo("houseRange");
  sleep(random(500, 700));
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  while (R_CountInventoryItem(currentFishID) > 0) do
  begin
    AntibanAndBreak(false);
    writelnex('Using range');
    Mouse.Click(julietRange.MidPoint, MOUSE_LEFT);
    timer.Start;
    while(not R_ChatSkillOption(1)) do
    begin
      if timer.ElapsedTime >= 1000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;
    //sleep(random(1000,1100));
    writelnex("Choosing Option");
    R_ChatSkillChooseOptions(1);
    sleep(random(1000,1100));
    AntibanAndBreak(false);
    timer.Start;
    while (player.isAnimating) do
    begin
      if timer.ElapsedTime >= 35000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;  
    AntibanAndBreak(false);
  end;
  julietRange.Free;

end;

procedure withdrawCookingItems;
var
  currentFishID, currentCookingLevel, currentFishes: Integer;
  currentFish: TRSBankItem;
begin
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  currentFishes := R_CountInventoryItem(currentFishID-2);
  fishesDone += currentFishes;

  if not openClosestBank then Exit;

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(800, 900));

  currentFish := R_FindBankItem(currentFishID);

  if (currentFish.id = -1) then
  begin
    writelnex("missing cook items, TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  R_WithdrawItem(currentFish.ID, 28);
  sleep(random(550,650));
  R_BankScreen_Close;
  sleep(random(600,850));
end;

function StrInArray(const Value : String;const ArrayOfString : Array of String) : Boolean;
var
 Loop : String;
begin
  for Loop in ArrayOfString do
  begin
    if Value = Loop then
    begin
       Exit(true);
    end;
  end;
  result := false;
end;

Function grainsGate(enter: Boolean): Boolean;
var
  openGate, closedGate: RSObject;
  tries, gateTries:    Integer;
begin
  closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
  openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
  if (openGate.ref = nil) and (closedGate.ref = nil) then
  begin
    writelnex("Grain gates not found");
    Exit(False);
  end;
  tries := 0;
  gateTries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering grain field');
    if player.inGrains then
    begin
      writelnex('Already inside');
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;
    //player.WalkTo("grainEnterSpot");
    while not player.inGrains do
    begin
      if tries > 10 then
      begin
        openGate.Free;
        closedGate.Free;
        Exit(False);
      end;
      //if player.Tile.Y >= 3457 then Break;
      gateTries := 0;
      while (closedGate.ref <> nil) and (gateTries < 10) do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
        inc(gateTries);
      end;
      //sleep(random(2000,2500) + lag);
      inc(tries);
      player.WalkTo("grainExitSpot");
    end;
  end else
  begin
    writelnex('Leaving Grain field');
    if not player.InGrains then
    begin
      writelnex('Already outside');
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;
    player.WalkTo("grainExitSpot");
    while player.InGrains do
    begin
      if tries > 10 then Exit(False);
      //if player.Tile.Y < 3444 then Break;
      gateTries := 0;
      while (closedGate.ref <> nil) and (gateTries < 10) do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);    
        inc(gateTries);
      end;
      player.WalkTo("grainEnterSpot");
      //sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  openGate.Free;
  closedGate.Free;
  Result:=True;
end;

Function cookGuildDoor(enter: Boolean): Boolean;
var
  cookDoor: RSObject;
  tries:    Integer;
begin
  cookDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3143, 3443);
  if (cookDoor.ref = nil) then
  begin
    writelnex("CookDoor not found");
    Exit(False);
  end;
  tries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering Cooks Guild door');
    if player.InGuild then
    begin
      writelnex('Already inside');
      exit(True);
    end;
    while player.Tile <> Point(3143, 3444) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y >= 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000,2500) + lag);
      inc(tries);
    end;
  end else
  begin
    writelnex('Leaving Cooks Guild door');
    if not player.InGuild then
    begin
      writelnex('Already outside');
      exit(True);
    end;
    player.WalkTo("cookExitSpot");
    while player.Tile <> Point(3143, 3443) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y < 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  cookDoor.Free;
  Result:=True;
end;


Function rangeDoor(enter: Boolean): Boolean;
var
  rangeDoor: RSObject;
  tries:    Integer;
  rangeBox: TBox;
begin
  rangeDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412);
  tries := 0;
  rangeBox := Box(3236, 3409, 3241, 3416);
  //openCookDoor;
  if enter then
  begin
  if player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already inside');
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      exit(True);
    end;
    writelnex('Entering Range door');
    player.WalkTo("eastToHouse");
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000,1500));
      inc(tries);
    end;
    player.WalkTo("houseRange");
    sleep(random(500, 700));
  end else
  begin
    writelnex('Leaving Range door');
    if not player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already outside');
      player.WalkTo("houseToEast");
      sleep(random(1000,1500));
      exit(True);
    end;
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseToEast");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000, 1500));
      inc(tries);
    end;
    player.WalkTo("houseToEast");
  end;
  rangeDoor.Free;
  Result:=True;
end;

Function climbStairs(direction:String): Boolean;
var
  cookStairs: RSobject;
  startingFloor: Integer;
begin
  writelnex('Climbing Stairs ' + direction);
  cookStairs := RSObject.Get(RSObjectType.GAME_OBJECT, 3144, 3447);
  if (cookStairs.ref = nil) then
  begin
    writelnex("cookStairs not found");
    Exit(False);
  end;
  startingFloor := RSClient.plane;
  Mouse.Move(cookStairs.MidPoint.X + random(30), cookStairs.MidPoint.y + random(30) - 105);
  Wait(150 + RandomRange(50,100));
  Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
  Wait(50 + RandomRange(50, 100));
  R_ChooseOptions(['Climb-' + direction +' Staircase']);
  Wait(500 + RandomRange(50, 100));
  {while (startingFloor = RSClient.plane) and (tries < 10) do
  begin
    Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
    Wait(50 + RandomRange(50, 100));
    R_ChooseOptions(['Climb-' + direction +'  Staircase']);
    Wait(500 + RandomRange(50, 100));
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;}
  cookStairs.Free;
  Result := True;
end;

Function climbToFloor(floor: Integer): Boolean;
var
  tries: Integer;
begin
  writelnex('Climbing to floor '+ inttostr(floor));
  while (RSClient.Plane <> floor) and (tries < 10)  do
  begin
    if RSClient.Plane = floor then Exit(True);
    if RSClient.Plane > floor then climbStairs("down") else climbStairs("up");
    sleep(500 + random(200, 300) + lag);
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;
end;

Function emptyFlourPot:Boolean;
var
  flourPot: Array of TRSInventoryItem;
begin
  flourPot := R_GetInventoryItem(flourPotID);
  if (Length(flourPot) > 0) then
  begin
    Mouse.click(flourPot[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Pot of flour']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //flourPot.Free;
end;

Function emptyWaterBucket:Boolean;
var
  waterBucket: Array of TRSInventoryItem;
begin
  waterBucket := R_GetInventoryItem(waterBucketID);
  if (Length(waterBucket) > 0) then
  begin
    Mouse.click(waterBucket[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Bucket of water']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //waterBucket.Free;
end;

procedure makeFlourToPizza;
var
  hopper, hopperControl, cookMill, cookPump: RSObject;
  flourPot, waterBucket, emptyBucket: Array of TRSInventoryItem;
  i, fails, currentGrains, breakHopperCounter: Integer;
  timer: Timer;
begin
  loginPlayer;
  writelnex('Making flourToPizza!');
  AntibanAndBreak;
  fails := 0;

  //CheckMill;
  writelnex('Checking Mill');
  cookMill := RSObject.Get(RSObjectType.GAME_OBJECT, 3140, 3449);
  if (cookMill.ref = nil) then
  begin
    writelnex("cookMill not found");
    Exit;
  end;
  //TODO check if not at cook then die
  while (R_CountInventoryItem(pizzaBaseID) < 26) do
  begin
    if not LoginPlayer then Exit; 
    ProgressReport;
    if (R_CountInventoryItem(grainID) < 1) then
    begin
      writelnex('Not going up because we aint got grains left');
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No flour on mill either, back to bank');
        isMillEmpty := True;
        Break;
      end;
    end else
    begin
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(random(500,700));
      emptyWaterBucket;
      ProgressReport;
      AntibanAndBreak;
      emptyFlourPot;
      climbToFloor(2);

      //third floor now
      writelnex('Filling Hopper');
      hopper := RSObject.Get(RSObjectType.GAME_OBJECT, 3142, 3452);
      if (hopper.ref = nil) then
      begin
        writelnex("hopper not found");
        Exit;
      end;
      Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
      //sleep(random(5000,3500));
      timer.Start;
      while(not player.Tile.Equals(Point(3142, 3451))) do
      begin
        if timer.ElapsedTime >= 5000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper at loop zero - if this keeps happening increase lag");
            Break;
          end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);
      AntibanAndBreak;
      ProgressReport;
      writelnex('Activating Hopper');
      hopperControl := RSObject.Get(RSObjectType.GAME_OBJECT, 3141, 3453);
      if (hopperControl.ref = nil) then
      begin
        writelnex("hopperControl not found");
        Exit;
      end;
      Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
      timer.Start;
      while(not player.Tile.Equals(Point(3141, 3452))) do
      begin
      if timer.ElapsedTime >= 5000 + lag then
        begin
          writeLnEx("At top floor - breaking hopperControl at loop zero - if this keeps happening increase lag");
          Break;
        end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);
      ProgressReport;
      currentGrains := R_CountInventoryItem(grainID);
      //TODO better check while shouldAddGrains do
      breakHopperCounter := 0;
      for i := 0 to 35 do
      begin
        ProgressReport;
        if (currentGrains < 1) then
        begin
          writelnEx("At top flor - No more grains");
          Break;
        end;
        if (i mod 10 = 0) then AntibanAndBreak;
        Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
        timer.Start;
        while(not (currentGrains <> R_CountInventoryItem(grainID))) do
        begin
          if timer.ElapsedTime >= 1000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper inside loop - if this keeps happening increase lag");
            break;
          end;
          Wait(50 + Random(50));
        end;
        timer.Reset;
        sleep(random(200,300) + lag);
        //sleep(random(1000,1500));
        Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
        //R_WaitFunction(1000, 100, currentGrains <> R_CountInventoryItem(grainID));
        sleep(random(1000,1500) + lag);
        if (currentGrains = R_CountInventoryItem(grainID)) then
        begin
          WriteLnEx(inttostr(breakHopperCounter) + "/ At top floor - Hopper seems full");
          if (breakHopperCounter > 7) then Break;
          inc(breakHopperCounter);
        end;
        currentGrains := R_CountInventoryItem(grainID);
      end;

      hopper.Free;
      hopperControl.Free;

    end;

    //climbDown;
    writelnex('Going down');
    climbToFloor(0);
    sleep(random(300,350));
    ProgressReport;
    //aca check mill antes

    player.walkTo("cookWaterSpot", True);
    timer.Start;
    while(not player.me.Tile.Equals(Point(3139, 3449))) do
    begin
      if timer.ElapsedTime >= 1800 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;

    //sleep(random(1500,2000));

    //CheckPump;
    writelnex('Checking Pump');
    cookPump := RSObject.Get(RSObjectType.GAME_OBJECT, 3138, 3449);
    if (cookPump.ref = nil) then
    begin
      writelnex("cookPump not found");
      Exit;
    end;

    //fill water, flour, make pizza, repeat

    while (R_CountInventoryItem(pizzaBaseID) < 26) do
    begin
      ProgressReport;
      //mill failsafe

      if fails > 3 then
      begin
        fails := 0;
        writelnex('Failing too much, bye');
        Break;
      end;

      if (Random(8) = 3) then AntibanAndBreak;

      //Check if inventory full but grains left
      if (R_InventoryCount > 27) AND (R_CountInventoryItem(grainID) > 1) then
      begin
        writelnex("Inventory full but still have grains left, going upstairs");
        Break;
      end;
      //fillWater
      if (R_CountInventoryItem(potID) <= 0) then
      begin
        writelnex("No empty pot");
        //Exit;  
        Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
        sleep(random(500,700));
        if not emptyFlourPot then Exit;
      end;

      emptyBucket := R_GetInventoryItem(bucketID);
      if (Length(emptyBucket) <= 0) then
      begin
        writelnex("No empty bucket");
        //Exit;              
        Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
        sleep(random(500,700));
        if not emptyWaterBucket then Exit;
        emptyBucket := R_GetInventoryItem(bucketID);
      end;
      sleep(random(150,200));
      Mouse.click(emptyBucket[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));

      Mouse.Click(cookPump.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(waterBucketID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      if (Random(10) = 3) then AntibanAndBreak;

      //sleep(random(1000,1000));

      //fill flour
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No more flour left');
        isMillEmpty := True;
        Break;
        inc(fails);
      end;
      ProgressReport;
      Mouse.Click(cookMill.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      if (Random(10) = 3) then AntibanAndBreak;
      //sleep(random(1000,1500));

      //makePizza
      waterBucket := R_GetInventoryItem(waterBucketID);
      flourPot := R_GetInventoryItem(flourPotID);
      if (Length(flourPot) <= 0) or (Length(waterBucket) <= 0) then
      begin
        writelnex("MISSING flourToPizza flourPot or waterBucket ITEMS, looping to se if we can empty some");
        Break;  // change to exit
      end;
      ProgressReport;
      Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));
      Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not R_ChatSkillOption(3)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(1000,1100));
      writelnex("Choosing Option");
      R_ChatSkillChooseOptions(3);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) = 0)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(500,700));
      if (R_CountInventoryItem(flourPotID) > 0) then
      begin
        writelnex('OptionFailsafe');
        Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
        sleep(random(50,100));
        Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
        sleep(random(800,900));
        R_ChatSkillChooseOptions(3);
        writelnex('Past failsafe');
        sleep(random(1500,2000));
      end
      if (Random(10) = 3) then AntibanAndBreak;

    end;
    cookPump.Free;

  end;

  writelnex('Full of pizza bases or no more flour left');
  isMillEmpty := (Length(cookMill.Model.Vertices) <> 316);
  cookMill.Free;
  //end floors repeat here
  //player.WalkToTileMS(Point(3143, 3446));
  //Mouse.Click(Point(6080, 6976), MOUSE_LEFT);
  //sleep(random(1000, 1500));

  //OutOfCook;
  //bank north booth 3186 3444

end;

procedure WheatProcedure;
var
  wheatObj: RSObject;
  tries, currentGrains: Integer;
  timer: Timer;
begin
  loginPlayer;
  AntibanAndBreak;
  grainsGate(true);
  AntibanAndBreak;
  if isMillEmpty then
  begin
    while (R_InventoryCount < 28)  and (tries < 50) do
    begin
      ProgressReport;
      inc(tries);
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      AntibanAndBreak;
    end;
  end else
  begin
    while (R_CountInventoryItem(GrainID) < 10) and (tries < 50) do
    begin
      ProgressReport;
      inc(tries);
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      AntibanAndBreak;
    end;
  end;
  wheatObj.Free;
  sleep(random(700, 1000));
  grainsGate(false);
end;

procedure grandExchange(buyGrains, sellPizzas: boolean);
begin
  if not player.inGE then Exit;
  withdrawGrandExchangeItems(buyGrains, sellPizzas);   
  sleep(20);
  reinitializeReflection(true);
  sleep(20);
  if not openClosestExchange then Exit;
  if sellPizzas then sellCancelAndCollect("Pizza base", notedPizzaBaseID, currentPizzaPrice);
  if buyGrains then buyCancelAndCollect("Grain", 500, currentGrainPrice);
  countGrandExchangeItems;
  R_GrandExchangeScreen_Close;
end;

function calculateEstimatedCashNeeded: Integer;
begin
  Result += (150-cShrimps) * currentShrimpPrice;
  Result += (170-cTrouts)  * currentTroutPrice;
  Result += (170-cSalmons) * currentSalmonPrice;
  Result += (2-cHats)      * currentHatPRice;
  Result += (10-cBuckets)  * currentBucketPrice;
  Result += (10-cPots)     * currentPotPrice;
end;

function buyResources: Boolean;
var
  estimatedCashNeeded: Integer;
begin
  if not player.inGE then Exit(False);
  openClosestBank("Grand Exchange booth", 10, "Bank Grand");
  checkCurrentResources;
  estimatedCashNeeded := calculateEstimatedCashNeeded;

  writelnEx("Need " + inttostr(estimatedCashNeeded) + " Coins");
  if cCoins < estimatedCashNeeded then
  begin
    R_BankScreen_Close;
    writelnEx("Not enough coins, need " + inttostr(estimatedCashNeeded));
    Exit(False);
  end;
  withdrawCoins;
  sleep(random(1500, 2000));
  R_BankScreen_Close;
  sleep(random(500, 800));
  if not openClosestExchange then Exit(False);
  sleep(random(1200, 1500));
  if cShrimps < 150 then buyCancelAndCollect("Raw shrimps", 150 - cShrimps, currentShrimpPrice);
  if cTrouts  < 170 then buyCancelAndCollect("Raw trout",   170 - cTrouts,  currentTroutPrice);
  if cSalmons < 170 then buyCancelAndCollect("Raw salmon",  170 - cSalmons, currentSalmonPrice);
  if cHats    < 2   then buyCancelAndCollect("Chef's hat",  2   - cHats,    currentHatPrice);
  if cBuckets < 10  then buyCancelAndCollect("Bucket",      10  - cBuckets, currentBucketPrice);
  if cPots    < 10  then buyCancelAndCollect("Pot",         10  - cPots,    currentPotPrice);
  buyCancelAndCollect("Grain", (R_GetInventoryItem(coinsID)[0].Amount div currentGrainPrice), currentGrainPrice);
  R_GrandExchangeScreen_Close;
  Result := True;
end;

procedure flourToPizzaProcedure;
begin
  if player.inGrains then
  begin
    writelnEx("inGrains");
    wheatProcedure;
    player.WalkTo("grainsToCook");
    sleep(random(700, 1000));
    AntibanAndBreak;
  end;
  if player.InGuild then
  begin
    loginPlayer;
    writelnEx("InGuild");
    climbToFloor(0);
    makeFlourToPizza;
    cookGuildDoor(False);
    AntibanAndBreak;
  end else
  begin
    if (R_CountInventoryItem(grainID) > 0) and (R_CountInventoryItem(PotID) > 0) and (R_CountInventoryItem(BucketID) > 0) then
    begin
      writelnEx("NotInGuild - bankToCook");
      player.walkTo("bankToCook");
      //sleep(random(700, 1000));
      cookGuildDoor(True);
      //sleep(random(700, 1000));
    end else
    begin
      writelnEx("NotInGuild - cookToBank");
      player.walkTo("cookToBank");
      //sleep(random(700, 1000));  
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(random(500,700));
      if emptyWaterBucket then sleep(random(700, 1000));
      if emptyFlourPot then ;sleep(random(700, 1000));
      sleep(random(700, 1000));
      withdrawFlourToPizzaItems;
      ProgressReport;
      if ((timeSinceLastGeVisit.ElapsedTime > (60 * 60 * 1000)) or ((runs < 1) and GEonFirstRun)) and useGe then
      begin
        reinitializeReflection;
        writelnEx("DOING GE");
        inc(geVisits);
        timeSinceLastGeVisit.Reset;
        timeSinceLastGeVisit.Start;
        player.WalkTo("bankToGe");
        sleep(random(700, 1000));
        if (grainsInBank < 2000) then
        begin
          WriteLnEx('GE: GrainsAndPizza, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(true, true);
        end else
        begin
          WriteLnEx('GE: PizzaOnly, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(false, true);
        end;
        sleep(random(700, 1000));
        player.WalkTo("geToBank");
        Exit;
      end;
      sleep(random(700, 1000));
      if pickWheat then
      begin
        player.WalkTo("bankToGrains");
        sleep(random(700, 1000));
        wheatProcedure;
        player.WalkTo("grainsToCook");
        sleep(random(700, 1000));
      end;
    end;
  end;
end;

procedure acceptTrade;
var
  i, j, tries: integer;
  Messages: Array of TRSChatMessage;
  widget: RSWidget;
begin
  for i := 0 to 30 do
  begin
    Messages := R_ChatMessages(0);
    For j := 0 to high(Messages) do
    begin
      if pos("wishes to trade", Messages[j].Message) > 0 then
      begin
        R_ClickChatMessage(Messages[j].LineNumber);
        sleep(Random(3000,5000));
        tries := 0;
        while tries < 10 do
        begin
          widget := RSWidget.Get(R_TRADE_FIRST_ACCEPT.Group, R_TRADE_FIRST_ACCEPT.Child);
          if widget.ref <> nil then
          begin
            Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
            widget.Free;
          end;

          sleep(random(800,1200));
          widget := RSWidget.Get(R_TRADE_SECOND_ACCEPT.Group, R_TRADE_SECOND_ACCEPT.Child);
          if widget.ref <> nil then
          begin
            Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
            widget.Free;
            sleep(random(4000,5200));
            widget := RSWidget.Get(R_TRADE_SECOND_ACCEPT.Group, R_TRADE_SECOND_ACCEPT.Child);
            if widget.ref = nil then
            begin
              tradeMode := false;
              exit;
            end;
            widget.Free;
          end;
          sleep(random(800,1200));
          inc(tries);
        end;
      end;
    end;
    sleep(random(5000,6000));
  end;
end;


Function getBotWebMessage: TWebMessage;
var
  response: String;
begin
  response := GetPage(actionWeb + "/botmessage.txt");
  if response <> "" then
  begin
    Result.name := substring(response, "name:'.", ".':name");
    Result.message := substring(response, "message:'.", ".':message");
    Result.target := "";
    Result.combat := StrToInt(substring(response, "combat:'.", ".':combat"));
  end;
end;

Function getMuleWebMessage: TWebMessage;
var
  response: String;
begin
  response := GetPage(actionWeb + "/mulemessage.txt");
  if response <> "" then
  begin
    Result.name := substring(response, "name:'.", ".':name");
    Result.message := substring(response, "message:'.", ".':message");
    Result.target := substring(response, "target:'.", ".':target");
    Result.combat := StrToInt(substring(response, "combat:'.", ".':combat"));
  end;
end;

Function isMuleMessage(message: String; tries: Integer; target: String): boolean;
var
  i: integer;
  wm: TWebMessage;
begin
  i := 0;
  while (i < tries) do
  begin
    wm := getMuleWebMessage;
    if (wm.message = message) and (wm.target = target) then
    begin
      Exit(True);
    end;
    sleepAndPrintProgressReport(500);
    inc(i);
  end;
  Result := False;
end;

Function isMuleMessage(messages: Array of String; tries: Integer; target: String): boolean; overload;
var
  i, j: integer;
  wm: TWebMessage;
begin
  i := 0;
  while (i < tries) do
  begin
    wm := getMuleWebMessage;
    for j := 0 to high(messages) do
    begin
      if (wm.message = messages[j]) and (wm.target = target) then
      begin
        Exit(True);
      end;
    end;
    sleepAndPrintProgressReport(500);
    inc(i);
  end;
  Result := False;
end;

Function isBotMessage(message: String; tries: Integer): boolean;
var
  i: integer;
  wm: TWebMessage;
begin
  i := 0;
  while (i < tries) do
  begin
    wm := getBotWebMessage;
    if wm.message = message then
    begin
      Exit(True);
    end;
    sleepAndPrintProgressReport(500);
    inc(i);
  end;
  Result := False;
end;

Function isBotMessage(messages: Array of String; tries: Integer): boolean; overload;
var
  i, j: integer;
  wm: TWebMessage;
begin
  i := 0;
  while (i < tries) do
  begin
    wm := getBotWebMessage;
    for j := 0 to high(messages) do
    begin
      if wm.message = messages[j] then
      begin
        Exit(True);
      end;
    end;
    sleepAndPrintProgressReport(500);
    inc(i);
  end;
  Result := False;
end;

Function CrossDitch(north: Boolean): Boolean;
var
  obj: RSObject;
  widget: RSWidget;
  tries: Integer;
begin
  tries := 0;
  while (tries < 15) do
  begin
    if north and (player.Tile.y > 3522) then
      Exit(True); 
    if (not north) and (player.Tile.y < 3521) then
      Exit(True);
    obj := R_GetClosestObjectByName("Wilderness Ditch", 5);
    if obj.ref = nil then
    begin
      WritelnEx('Couldnt get ditch');
      setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
      player.WalkTo("wildToBank");
      Exit;
    end;

    Mouse.Click(obj.midpoint, "Cross", 5, MOUSE_LEFT);
    sleep(Random(2500, 3500));
    widget := RSWidget.Get(R_WILDERNESS_WARNING_ENTER.group, R_WILDERNESS_WARNING_ENTER.child);
    if widget.ref <> nil then
    begin
      Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
      widget.Free;
      sleep(Random(2000,3000));
    end;
    sleep(Random(2000,3000));
    inc(tries);
  end;
  Exit(False);
end;

Function attackPlayer(name: String): Boolean;
var
  enemy: RSPlayer;
  players: Array of RSPlayer;
  i, tries: integer;
begin
  players := RSPlayer.AllPlayers;
  for i := 0 to High(players) do
  begin
    writeln(players[i].Name);
    if players[i].Name = name then
    begin
      enemy := players[i];
      break;
    end;
  end;

  if enemy.ref = nil then
    Exit(False);
  for tries := 0 to 3 do
  begin
    Mouse.Move(0, 0);
    sleep(random(100,200));
    Mouse.Click(enemy.MidPoint, name, 5, MOUSE_RIGHT);
    sleep(Random(100,200));
    if R_ChooseOptions(['ttack ' + name]) then
    begin
      sleep(Random(300,500));
      Exit(True);
    end;
  end;
  Exit(False);
end;

Function isPlayerVisible(name: String): Boolean;
var
  enemy: RSPlayer;
  players: Array of RSPlayer;
  i: integer;
begin
  players := RSPlayer.AllPlayers;
  for i := 0 to High(players) do
  begin
    writeln(players[i].Name);
    if players[i].Name = name then
    begin
      enemy := players[i];
      break;
    end;
  end;

  if enemy.ref = nil then
    Exit(False);
  if enemy.IsVisible then
  begin
    enemy.Free;
    RSTypeARray(players).Free;
    Exit(True);
  end;
end;

procedure muleItems;
var
  webMuleMessage: TWebMessage;
  tries, desiredWildLevel: Integer;
  widget: RSWidget;
Label
  alreadyInDitch;
begin
  writelnEx("MuleItems");
  if not LoginPlayer then Exit;

  setBotWebMessage(player.Name, 'request mule', player.CombatLevel);
  writelnex("MI2");

  webMuleMessage := getMuleWebMessage;
  writelnex("MI3");
  if not isMuleMessage("available", 5, player.Name) then
  begin
    WritelnEx("Mule not available"); 
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;
  writelnex("MI4");

  if player.inWildDitch then
    GoTo alreadyInDitch;

  setBotWebMessage(player.Name, 'getting gold', player.CombatLevel);

  if not player.inGE then
  begin
    if player.InGuild then
    begin
      writelnEx("InGuild");
      climbToFloor(0);
      cookGuildDoor(False);
    end;
    player.WalkTo("cookToBank");
    player.WalkTo("bankToGe");
  end;
   
  reinitializeReflection;
  grandExchange(false, true);   //sell pizzas
  sleep(Random(1500,3000));
  withdrawWildItems;
  sleep(Random(1500,3000));
  if (High(R_GetInventoryItem(coinsID)) < 0) or (R_GetInventoryItem(coinsID)[0].Amount < 1) then
  begin
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;

  setBotWebMessage(player.Name, 'going to wild border', player.CombatLevel);

  writelnEx("Waiting for Mule to start going to border");
  if not isMuleMessage(["going to wild border", "arrived at wild border"], 30, player.Name) then
  begin         
    writelnEx("Mule is not going to wild border");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;
  player.WalkTo("geToBank");
  player.WalkTo("bankToWild");
  reinitializeReflection;
  sleep(Random(1500,3000));

  AlreadyInDitch:
  setBotWebMessage(player.Name, 'arrived at wild border', player.CombatLevel);

  writelnEx("Waiting for Mule to arrive at border");
  if not isMuleMessage(["arrived at wild border", "crossed ditch", "arrived at wild level"], 150, player.Name) then
  begin      
    writelnEx("Mule never arrived at wild border");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wildToBank");
    Exit;
  end;

  webMuleMessage := getMuleWebMessage;
  desiredWildLevel := abs(player.CombatLevel - webMuleMessage.combat);
  WritelnEx("should walk til wild lvl " + IntToStr(desiredWildLevel));

  Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);
  sleep(Random(1000,1500));
  widget := RSWidget.Get(R_COMBAT_RETALIATE_TEXT.group, R_COMBAT_RETALIATE_TEXT.child);
  if widget.ref <> nil then
  begin
    if pos("On",widget.Text) > 0 then
      Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
    sleep(500);
    widget.Free;
  end;

  writelnEx("Crossing ditch");
  if not CrossDitch(true) then
  begin
    WritelnEx('Couldnt cross ditch');
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wildToBank");
    Exit;
  end;

  setBotWebMessage(player.Name, 'crossed ditch', player.CombatLevel);

  writelnEx("Waiting for Mule to cross ditch");
  if not isMuleMessage(["crossed ditch", "arrived at wild level"], 30, player.Name) then
  begin
    writelnEx("Mule never crossed the ditch");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    crossDitch(false);
    player.WalkTo("wildToBank");
    Exit;
  end;

  case desiredWildLevel of
    0..3: begin player.WalkTo("wild4") end;
    4..7: begin player.WalkTo("wild8") end;
    8..11: begin player.WalkTo("wild12") end;
    12..15: begin player.WalkTo("wild16") end;
    16..19: begin player.WalkTo("wild20") end;
    20..23: begin player.WalkTo("wild24") end;
    else begin WritelnEx('mucha diff') end;
  end;
  
  reinitializeReflection;
  setBotWebMessage(player.Name, 'arrived at wild level', player.CombatLevel);

  writelnEx("Waiting for Mule to arrive at wild level");
  if not isMuleMessage("arrived at wild level", 30, player.Name) then
  begin
    writelnEx("Mule never arrived at wild level");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToBank");
    Exit;
  end;

  for tries := 0 to 5 do
  begin
    if attackPlayer(webMuleMessage.name) then
    begin
      setBotWebMessage(player.Name, 'attacked', player.CombatLevel);
      sleep(Random(1500, 2500));
      player.WalkToTileMM(player.Tile, 2, 2);
      break;
    end;
    if tries > 4 then
    begin
      writelnEx("Could not attack mule");
      setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
      player.WalkTo("wild0");
      crossDitch(false);
      player.WalkTo("wildToBank");
      Exit;
    end;
    inc(tries);
  end;
end;

procedure muleProcedure;
var
  webBotMessage: TWebMessage;
  tries, desiredWildLevel: Integer;
  widget: RSWidget;
  coinsArray: Array of RSTile;
begin
  WritelnEx("Starting mule procedure");
  LoginPlayer;

  player.WalkTo("geToBank");
  player.WalkTo("bankToEast");
  player.WalkTo("wildToEast");

  if (not isBotMessage(["request mule","getting gold", "going to wild border"], 30)) then
    LogoutPlayer;

  writelnEx("Waiting for Bot to start going to border");
  for tries := 0 to 50 do
  begin
    if isBotMessage(["request mule", "getting gold", "going to wild border"], 1) then
    begin
      webBotMessage := getBotWebMessage;
      setMuleWebMessage(player.Name, 'available', webBotMessage.target, player.CombatLevel);
      if not LoginPlayer then
      begin
        setMuleWebMessage("", 'cancel', webBotMessage.target, 0);
        Exit;
      end;
      setMuleWebMessage(player.Name, 'going to wild border', webBotMessage.target, player.CombatLevel);
      Break;
    end;
    sleep(10000);
  end;

  if tries > 49 then
  begin
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    Exit;
  end;

  player.WalkTo("bankToWild");
  setMuleWebMessage(player.Name, 'arrived at wild border', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to arrive at border");
  if not isBotMessage(["arrived at wild border", "crossed ditch"], 150) then
  begin
    writelnEx("Bot never arrived at wild border");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wildToEast");
    Exit;
  end;

  webBotMessage := getBotWebMessage;
  desiredWildLevel := abs(player.CombatLevel - webBotMessage.combat);
  WritelnEx("should walk til wild lvl " + IntToStr(desiredWildLevel));

  Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);
  sleep(Random(1000,1500));
  widget := RSWidget.Get(R_COMBAT_RETALIATE_TEXT.group, R_COMBAT_RETALIATE_TEXT.child);
  if widget.ref <> nil then
  begin
    if pos("Off",widget.Text) > 0 then
      Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
    sleep(500);
    widget.Free;
  end;

  writelnEx("Crossing Ditch");
  if not CrossDitch(true) then
  begin
    WritelnEx('Couldnt cross ditch');
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wildToEast");
    Exit;
  end;

  setMuleWebMessage(player.Name, 'crossed ditch', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to cross ditch");
  if not isBotMessage(["crossed ditch", "arrived at wild level"], 30) then
  begin
    writelnEx("Bot never crossed the ditch");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  case desiredWildLevel of
    0..3: begin player.WalkTo("wild4") end;
    4..7: begin player.WalkTo("wild8") end;
    8..11: begin player.WalkTo("wild12") end;
    12..15: begin player.WalkTo("wild16") end;
    //16..19: begin player.WalkTo("wild20") end;
    //20..23: begin player.WalkTo("wild24") end;
    else begin WritelnEx('mucha diff') end;
  end;

  setMuleWebMessage(player.Name, 'arrived at wild level', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to arrive at wild level");
  if not isBotMessage(["arrived at wild level", "attacked"], 30) then
  begin
    writelnEx("Bot never arrived at wild level");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  writelnEx("Waiting for Bot to attack us");
  if not isBotMessage("attacked", 30) then
  begin
    writelnEx("Bot never attacked");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  sleep(Random(1500, 2000));

  tries := 0;
  while tries < 120 do
  begin
    if not attackPlayer(webBotMessage.name) then
    begin
      WritelnEx("Bot is not here, maybe dead?");
      coinsArray := R_GetMainscreenGroundItemByID(995);
      while High(coinsArray) > -1 do
      begin
        Mouse.Move(0, 0);
        Mouse.Click(coinsArray[0], MOUSE_RIGHT);
        sleep(Random(100,200));
        if R_ChooseOptions(['ake Coin']) then
        begin
          sleep(Random(1000,1500));
        end;
        coinsArray := R_GetMainscreenGroundItemByID(995);
      end;
      WritelnEx("No more coins");

      if not isPlayerVisible(webBotMessage.name) then
      begin
        WritelnEx("No more coins or player, bye");
        setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
        player.WalkTo("wild0");
        crossDitch(false);
        player.WalkTo("wildToEast");
        if player.inEastBank then
        begin
          openClosestBank;
          R_DepositAll_Items;
          sleep(random(1000,1500));
          R_BankScreen_Close;
        end;
        Exit;
      end;
    end;
    sleep(Random(800,1200));
    inc(tries);
  end;
end;

procedure cookingProcedure;
begin
  while (player.me.SkillLevel(7) < 32) do
  begin
    rangeDoor(False);
    AntibanAndBreak;
    sleep(random(700, 1000));
    player.walkTo("bankToEast");
    sleep(random(700, 1000));
    player.walkTo("houseToEast");
    sleep(random(700, 1000));
    withdrawCookingItems;
    progressReport;
    AntibanAndBreak;
    sleep(random(700, 1000));
    player.walkTo("eastToHouse");
    sleep(random(700, 1000));
    rangeDoor(True);
    sleep(random(700, 1000));
    cookFish;
    if player.me.SkillLevel(7) >= 32 then
    begin
      writelnex("Already at 32 cooking, bye");
      progressReport;
      rangeDoor(False);
      player.WalkTo("eastToBank");
      Exit;
    end;
  end;
end;

procedure keepAliveProcedure;
begin
  player.walkToTileMM(startPos, -10, 10);
  wait(60000 + random(5000, 30000));
end;

procedure wildProcedure;
begin
  if player.InGuild then
  begin
    writelnEx("InGuild");
    climbToFloor(0);
    cookGuildDoor(False);
  end;
  player.walkto("cookToBank");
  sleep(random(700, 1000));
  withdrawWildItems;
  player.WalkTo("bankToGe");
  sleep(random(700, 1000));
  WritelnEx("Not selling pizzas, do it yourself");
  depositGrains;
  writelnEx('deposited');
  player.WalkTo("geToBank");
  sleep(random(700, 1000));
  player.WalkTo("bankToWild");
  sleep(random(700, 1000));
  TerminateScript;
end;

procedure hybridProcedure;
begin             
  AntibanAndBreak;
  if R_InTutorialIsland then
  begin
    writelnEx("InTutIsland");
    R_TutorialIsland("");
  end;

  if player.InLumby then
  begin
    writelnEx("InLumby");
    player.walkTo("lumbyToVarrock");
  end;

  if player.InGE then
  begin
    writelnEx("InGE");
    player.walkTo("geToBank");
  end;

  if player.me.SkillLevel(7) < 32 then
  begin
    writelnex("Getting that cooking up");    
    AntibanAndBreak;
    if player.inEastBank then
    begin
      checkCurrentResources("Bank booth", "Bank Bank");
      if (cShrimps > 2) or (cTrouts > 2) or (cSalmons > 2) then
        cookingprocedure;
    end;

    if player.inWestBank then
    begin
      if tradeMode then
      begin
        acceptTrade;
      end else
      begin
        checkCurrentResources("Bank booth", "Bank Bank");
        if (cShrimps < 150) or (cTrouts < 170) or (cSalmons < 170) then
        begin
          if cCoins < calculateEstimatedCashNeeded then
          begin
            //shouldRunOneOff := false;
            tradeMode := true;
            writelnEx('No cooking level, no fish in bank, and no money, halt until we get dem fishes');
            //acceptTradesMode 
            player.walkToTileMM(Point(3184, 3438), -3, 3);
            sleep(random(2000,4000));
            Exit;
          end else
          begin
            player.walkTo('bankToGe');
            AntibanAndBreak;
            buyResources;
            player.WalkTo('geToBank');
            openClosestBank;
            R_DepositAll_Items;
            sleep(random(1000,1500));
            R_BankScreen_Close;
          end;
        end else
          cookingProcedure;
      end;
    end;
  end else
  begin
   flourToPizzaProcedure;
  end;
end;

procedure testProcedure;
var
  obj: RSObject;
begin
  writeln("testing");
  tradeNPC(2891, "errant");
  sleep(4000);
  BuyShopItem("Feather", 10, 100);
  TerminateScript;
end;

Function isWebActionValid(action: String): Boolean;
var
  i: Integer;
  validActions: TStringArray;
begin
  validActions := ["hybrid", "doWild", "doBotMule", "doMule", "doTest", "walkToGe", "walkToBank", "walkToWild", "pause", "buyGrains", "buyResources", "sellPizzas", "withdrawWildItems"];
  for i := 0 to high(validActions) do
    if validActions[i] = action then Exit(true);
end;

Function getWebPlayer: TWebPlayer;
var
  response: String;
begin
  if scriptID[currentSet] = "" then Exit;
  response := GetPageEx(actionWeb + "/enviar.php?getuserfromscript=" + scriptID[currentSet]);
  if response <> "" then
  begin
    Result.email := substring(response, "email:'.", ".':email");
    Result.password := substring(response, "password:'.", ".':password");
    Result.user := substring(response, "username:'.", ".':username");
    Result.action := substring(response, "action:'.", ".':action");
    Result.scriptId := substring(response, "scriptid:'.", ".':scriptid");
    Result.active := StrToBool(substring(response, "active:'.", ".':active"));
    Result.online := StrToBool(substring(response, "online:'.", ".':online"));
  end;
end;

Function getWebScript: TWebScript;
var
  response: String;
begin
  if scriptID[currentSet] = "" then Exit;
  response := GetPageEx(actionWeb + "/" + scriptID[currentSet] + ".txt");
  if response <> "" then
  begin
    Result.ID           := strtoint(scriptID[currentSet]);
    Result.action       := substring(response, "action:'.", ".':action");
    Result.grainPrice   := strtoint(substring(response, "grainprice:'.", ".':grainprice"));
    Result.pizzaPrice   := strtoint(substring(response, "pizzaprice:'.", ".':pizzaprice"));
    Result.shrimpPrice  := strtoint(substring(response, "shrimpprice:'.", ".':shrimpprice"));
    Result.troutPrice   := strtoint(substring(response, "troutprice:'.", ".':troutprice"));
    Result.salmonPrice  := strtoint(substring(response, "salmonprice:'.", ".':salmonprice"));
    Result.hatPrice     := strtoint(substring(response, "hatprice:'.", ".':hatprice"));
    Result.potPrice     := strtoint(substring(response, "potprice:'.", ".':potprice"));
    Result.bucketPrice  := strtoint(substring(response, "bucketprice:'.", ".':bucketprice"));
  end;
end;

label TryAgain;

procedure setLoop
begin
  currentAccountTimer.Reset;
  currentAccountTimer.Start;
  while not shouldChangeAccount(accountMinutes) do
  begin                   
    TryAgain:
    timeSinceLastGeVisit.Reset;
    timeSinceLastGeVisit.Start;
    currentSprintTimer.Reset;
    currentSprintTimer.Start;
    webPlayer := getWebPlayer;
    if (P_USERNAME <> "") and (P_PASSWORD <> "") then
    begin
      currentUser := P_USERNAME;
      currentPassword := P_PASSWORD;
    end else
    if (webPlayer.email <> "") and (webPlayer.password <> "") and (not webPlayer.online) then
      begin
        currentUser := webPlayer.email;
        currentPassword := webPlayer.password;
    end else
    begin
      WritelnEx("No USER set and can't get one from the site [ScriptID:"+ScriptID[currentSet]+"], sleeping 5 min and retrying", true);
      SleepAndPrintProgressReport(5 * 60 * 1000);
      if shouldChangeSet(setMinutes + Random(randomSetMinutes)) then Exit;
      goto TryAgain;
    end;

    while True do
    begin
      Try
        if scriptID[currentSet] <> "" then webScript := getWebScript;
        writeln(webScript);
        if isWebActionValid(webScript.action) then
        begin
          if action <> webScript.action then shouldRunOneOff := True;
          action              := webScript.Action;
          currentGrainPrice   := webScript.grainPrice;
          currentPizzaPrice   := webScript.pizzaPrice;
          currentShrimpPrice  := webScript.shrimpPrice;
          currentTroutPrice   := webScript.troutPrice;
          currentSalmonPrice  := webScript.salmonPrice;
          currentHatPrice     := webScript.hatPrice;
          currentPotPrice     := webScript.potPrice;
          currentBucketPrice  := webScript.bucketPrice;
        end else
        begin
          action              := userAction;
          currentGrainPrice   := GRAIN_PRICE;
          currentPizzaPrice   := PIZZA_PRICE;
          currentShrimpPrice  := SHRIMP_PRICE;
          currentTroutPrice   := TROUT_PRICE;
          currentSalmonPrice  := SALMON_PRICE;
          currentHatPrice     := HAT_PRICE;
          currentPotPrice     := POT_PRICE;
          currentBucketPrice  := BUCKET_PRICE;
        end;

        player.Free;
        progressReport;
        if shouldChangeSet(setMinutes + Random(randomSetMinutes)) then
        begin
          logoutPlayer;
          Exit;
        end;
        if shouldChangeAccount(accountMinutes + Random(randomAccountMinutes)) then
        begin
          logoutPlayer;
          Break;
        end;
        if (not loginPlayer) then goto TryAgain;
        currentBaseX := RSCLient.BaseX;
        currentBaseY := RSCLient.basey;
        currentPlane := RSCLient.Plane;
        player := RSPlayer.Me;
        startPos := player.Tile;
        player.ToggleRun(True);

        case action of
          "keepAlive": begin keepAliveProcedure end;
          "doTest":   begin testProcedure; end;
          "doMule":   begin muleProcedure; end;
          "doBotMule":   begin muleItems; end;
          "doWild":   begin wildProcedure; end;
          "hybrid":   begin if shouldRunOneOff then hybridProcedure end;
          "walkToGe":   begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            player.WalkTo("bankToGe");
                          end;
                        end;
          "walkToBank":   begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            writeln('a');
                            player.WalkTo("geToBank");
                            writeln('b');
                          end;
                        end;
          "walkToWild":  begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            player.WalkTo("geToBank");
                            player.WalkTo("bankToWild");
                          end;
                        end;
          "sellPizzas": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            grandExchange(false, true);
                          end;
                        end;
          "buyGrains": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            grandExchange(true, false);
                          end;
                        end;
          "buyResources": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            buyResources;
                          end;
                        end;
          "withdrawWildItems": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000);
                          end else
                          begin
                            shouldRunOneOff := false;
                            withdrawWildItems;
                          end;
                        end;
          "pause":      begin
                          writeLnEx("PAUSE", true);
                            SleepAndPrintProgressReport(10 * 1000);
                        end;
          else
          begin
            WriteLnEx("NO VALID ACTION FOUND", true);
            TerminateScript;
          end;
        end;
        inc(runs);
        reinitializeReflection;
      Except
        //E: Exception do writelnex("ERROR "+ E.message);
        progressReport;
        WriteLnEx(GetExceptionMessage, true);
      end;
    end;
    player.Free;
  end;
  writelnEx('Switching to new account', true);

end;

procedure nextSet;
var
  maxSets: Integer;
begin
  maxSets := High(ScriptID);
  inc(currentSet);
  if currentSet > maxSets then
    currentSet := 0;
end;

procedure workbitch;
begin
  currentSet := 0;
  {SetLength(ScriptID, Length(Scripts));
  ScriptID := Scripts;
  if (High(ScriptID) < 0) then
  begin
    SetLength(ScriptID, 1);
    ScriptID[currentSet] := "";
  end;   }
  timerTrack.Start;
  startTime := Now;
  antibanMark.Start;
  pizzasDone := 0;
  floursDone := 0;
  geVisits := 0;
  pickWheat := True;
  sellPizzas := False;
  runs := 0;
  ClearDebug;
  shouldRunOneOff := true;  
  setupDrawing;
  while True do
  begin             
    currentSetTimer.Reset;
    currentSetTimer.Start;
    while not ShouldChangeSet(setMinutes) do
    begin
      setLoop;
    end;
    WritelnEx("Switching to next set");
    nextSet;
  end;
end;
