{$include_once reflection/GrandExchange.simba}
{$include_once reflection/Login.simba}
{$include_once reflection/Helpers.simba}
{$include_once reflection/Debug.simba}
{$include_once reflection/Tutorial.simba}
{$include_once reflection/Antiban.simba}
{$include_once reflection/Trade.simba}
{$include_once franher/shared.simba}
{$include_once franher/Web.simba}

procedure ProgressReport;
var
  debugStrings: TStringArray;
begin
  if useDebug then
  begin
    writelnex('##########  PROGRESS  ##########');
    writelnex('## CURRENT TIME: ' + FormatDateTime('hh:nn:ss',now));
    writelnex('## Time Running: ' + FormatDateTime('hh:nn:ss',now-startTime));
    writelnex('## Set Runtime:  ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime));
    writelnex('## Account time: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime));
    writelnex('## Sprint time : ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime));
    writelnex('## RUNS        : ' + intToStr(runs));
    writelnex('## Flours      : ' + intToStr(floursDone));
    writelnex('## Pizzas      : ' + intToStr(pizzasDone));
    writelnex('## Fishes      : ' + intToStr(fishesDone));
    writelnex('## GE VISITS   : ' + intToStr(geVisits));
    writelnex('## -------  PER HOUR  ------- ##');
    writelnex('## RUNS        : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * runs)));
    writelnex('## Flours      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * floursDone)));
    writelnex('## Pizzas      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * pizzasDone)));
    writelnex('## Fishes      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * fishesDone)));
    writelnex('## GE visits   : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * geVisits)));
    writelnex('################################');
    writelnex('GTR: ' + inttostr(GetTimeRunning));
    writelnex('TSLGEV: ' + inttostr(TimeSinceLastGeVisit.ElapsedTime));
  end;
  debugStrings := [ CurrentUser + ': TabID: ' + TabID + ' - ScriptID: ' + scriptID[currentSet] + ' - Action: ' + action,
                    //'Time running: ' + FormatDateTime('dd:hh:nn:ss',now-startTime) + ' Set: ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime) + ' Acc: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime) + ' Sprint: ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime),
                    'Time running: ' + TimerToTime(timerTrack.ElapsedTime) + ' Set: ' + MStoFormattedTime(CurrentSetTimer.ElapsedTime) + ' Acc: ' + MStoFormattedTime(CurrentAccountTimer.ElapsedTime) + ' Sprint: ' + MStoFormattedTime(CurrentSprintTimer.ElapsedTime),
                    'Runs       : ' + intToStr(runs) + debugTabulator(intToStr(runs)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * runs)),
                    'Pizzas    : ' + intToStr(pizzasDone) + debugTabulator(intToStr(pizzasDone)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * pizzasDone)),
                    'Pizzas in bank: ' + intToStr(totalPizzas) + ' | Pizzas in GE: ' + intToStr(pizzasInGe),
                    'Grains in bank: ' + intToStr(totalGrains) + ' | Grains in GE: ' + intToStr(grainsInGe),
                    'Coins in bank: ' + intToStr(totalCoins),
                    'GE visits : ' + intToStr(geVisits) + debugTabulator(intToStr(geVisits)) + " | " + inttostr( Round(60 / (GetTimeRunning/1000/60) * geVisits)),
                    'Time since last GE visit: ' +  inttostr(TimeSinceLastGeVisit.ElapsedTime div 1000 div 60)];
  writeDebug(debugStrings);
end;

function RSPlayer.WalkTo(destination: String; precise: Boolean = False): Boolean;
var
  geToBankTiles, bankToCookTiles, cookToBankTiles, bankToGETiles, cookWaterSpot, cookExitSpot,
  lumbyToVarrock, bankToWild, wildToBank, wildToEast, bankToEast, eastToHouse, houseRange,
  houseDoorInside, houseToEast, eastToBank, bankToGrains, grainsToCook, grainExitSpot,
  grainEnterSpot, tToFish, tToFishGate, tToChef, tExitChef,
  tToQuest, ttoMiningInstructor, tToMiningGate, tToRats, tToBank, tToPrayer,
  tToMagic, wild0, wild4, wild8, wild12, wild16, wild20, wild24, choosenTile: Array of RSTile;
  tries: Integer;
begin
  geToBankTiles   := [Point(3165, 3483), Point(3165, 3486), Point(3166, 3471),
                      Point(3170, 3457), Point(3182, 3449),
                      Point(3183, 3445)];

  bankToCookTiles := [Point(3183, 3444), Point(3182, 3451),
                      Point(3173, 3452), Point(3165, 3451),
                      Point(3157, 3448), Point(3151, 3444),
                      Point(3146, 3441), Point(3143, 3442)];

  cookToBankTiles := [Point(3143, 3440), Point(3146, 3441),
                      Point(3151, 3444), Point(3157, 3448),
                      Point(3165, 3451), Point(3173, 3452),
                      Point(3182, 3451), Point(3183, 3444)];

  bankToGETiles   := [Point(3184, 3444), Point(3178, 3459),
                      Point(3166, 3460), Point(3166, 3468),
                      Point(3164, 3481), Point(3164, 3484)];

  cookWaterSpot   := [Point(3139, 3449)];

  cookExitSpot    := [Point(3143, 3446)];

  bankToWild      := [Point(3183, 3444), Point(3183, 3448),
                      Point(3189, 3448), Point(3196, 3448),
                      {Point(3202, 3442),} Point(3207, 3438),
                      Point(3213, 3435), Point(3220, 3430),
                      Point(3226, 3430), Point(3233, 3430),
                      Point(3239, 3430), Point(3246, 3430),
                      Point(3253, 3430), Point(3260, 3430),
                      Point(3266, 3430), Point(3274, 3431),
                      Point(3275, 3437), Point(3279, 3440),
                      Point(3282, 3447), Point(3286, 3453),
                      Point(3288, 3461), Point(3293, 3467),
                      Point(3295, 3473), Point(3299, 3479),
                      Point(3304, 3485), Point(3310, 3488),
                      Point(3315, 3491), Point(3320, 3498),
                      Point(3325, 3502), Point(3326, 3508),
                      Point(3326, 3516), Point(3323, 3520)];

  wildToBank      := [Point(3325, 3520),
                      Point(3325, 3517), Point(3326, 3511),
                      Point(3326, 3505), Point(3326, 3498),
                      Point(3321, 3494), Point(3317, 3492),
                      Point(3310, 3488), Point(3307, 3483),
                      Point(3301, 3479), Point(3297, 3473),
                      Point(3297, 3467), Point(3293, 3460),
                      Point(3286, 3453), Point(3286, 3447),
                      Point(3286, 3440), Point(3286, 3434),
                      Point(3280, 3429), Point(3275, 3428),
                      Point(3269, 3428), Point(3263, 3428),
                      Point(3256, 3428), Point(3250, 3428),
                      Point(3243, 3428), Point(3236, 3428),
                      Point(3230, 3428), Point(3222, 3428),
                      Point(3215, 3432), Point(3210, 3432),
                      Point(3205, 3438), Point(3199, 3438),
                      Point(3194, 3442), Point(3191, 3448),
                      Point(3184, 3448), Point(3183, 3445)];

    wildToEast      := [Point(3325, 3520),
                      Point(3325, 3517), Point(3326, 3511),
                      Point(3326, 3505), Point(3326, 3498),
                      Point(3321, 3494), Point(3317, 3492),
                      Point(3310, 3488), Point(3307, 3483),
                      Point(3301, 3479), Point(3297, 3473),
                      Point(3297, 3467), Point(3293, 3460),
                      Point(3286, 3453), Point(3286, 3447),
                      Point(3286, 3440), Point(3286, 3434),
                      Point(3280, 3429), Point(3275, 3428),
                      Point(3269, 3428), Point(3263, 3428),
                      Point(3256, 3428), Point(3252, 3427),
                      Point(3253, 3421), Point(3253, 3420)];

  lumbyToVarrock  := [Point(3222, 3218), Point(3227, 3218),
                      Point(3232, 3220), Point(3232, 3226),
                      Point(3232, 3232), Point(3234, 3239),
                      Point(3232, 3243), Point(3232, 3250),
                      Point(3231, 3256), Point(3229, 3261),
                      Point(3236, 3261), Point(3242, 3263),
                      Point(3243, 3270), Point(3241, 3277),
                      Point(3239, 3283), Point(3238, 3289),
                      Point(3238, 3295), Point(3238, 3301),
                      Point(3234, 3307), Point(3227, 3311),
                      Point(3225, 3317), Point(3221, 3323),
                      Point(3218, 3329), Point(3212, 3334),
                      Point(3206, 3341), Point(3204, 3346),
                      Point(3205, 3352), Point(3210, 3360),
                      Point(3211, 3366), Point(3211, 3373),
                      Point(3211, 3379), Point(3211, 3386),
                      Point(3211, 3393), Point(3211, 3399),
                      Point(3208, 3406), Point(3202, 3413),
                      Point(3200, 3419), Point(3196, 3425),
                      Point(3190, 3428), Point(3183, 3432),
                      Point(3183, 3439), Point(3183, 3441)];

  bankToEast      := [Point(3183, 3442),
                      Point(3183, 3436), Point(3185, 3432),
                      Point(3192, 3432), Point(3199, 3431),
                      Point(3206, 3429), Point(3212, 3429),
                      Point(3218, 3429), Point(3225, 3429),
                      Point(3232, 3429), Point(3238, 3429),
                      Point(3245, 3429), Point(3252, 3427),
                      Point(3253, 3421), Point(3253, 3420)];

   eastToHouse     := [Point(3253, 3420), Point(3253, 3424),
                       Point(3248, 3428), Point(3247, 3422),
                       Point(3245, 3416), Point(3242, 3412)];

   houseRange       := [Point(3238, 3410)];

   houseDoorInside  := [Point(3241, 3412)];

   houseToEast      := [Point(3241, 3412), Point(3242, 3414),
                        Point(3242, 3420), Point(3247, 3427),
                        Point(3253, 3426), Point(3254, 3420)];

   eastToBank       := [Point(3253, 3420), Point(3253, 3426),
                        Point(3247, 3428), Point(3241, 3428),
                        Point(3235, 3428), Point(3228, 3428),
                        Point(3221, 3428), Point(3215, 3432),
                        Point(3208, 3432), Point(3202, 3428),
                        Point(3196, 3428), Point(3190, 3428),
                        Point(3183, 3432), Point(3184, 3438)];

   tToFish          := [Point(3103, 3102), Point(3103, 3096)];

   tToFishGate      := [Point(3095, 3092), Point(3090, 3091)];

   tToChef          := [Point(3079, 3084)];

   tExitChef        := [Point(3073, 3090)];

   tToQuest         := [Point(3076, 3106),Point(3076, 3118),
                        Point(3086, 3126)];

   tToMiningInstructor  := [Point(3078, 9515),Point(3081, 9504)];

   tToMiningGate        := [Point(3094, 9502)];

   tToRats        := [Point(3111, 9518)];

   tToBank        := [Point(3122, 3123)];

   tToPrayer      := [Point(3133, 3115), Point(3125, 3107)];

   tToMagic       := [Point(3130, 3092), Point(3141, 3087)];

   grainEnterSpot  := [Point(3142, 3454)];

   grainExitSpot  := [Point(3142, 3460)];

   bankToGrains     := [Point(3181, 3451),
                        Point(3175, 3453), Point(3169, 3456),
                        Point(3163, 3456), Point(3156, 3456),
                        Point(3149, 3456), Point(3142, 3457)];

   grainsToCook     := [Point(3142, 3457),
                        Point(3137, 3452), Point(3137, 3446),
                        Point(3143, 3442)];

   wild4            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546)];

   wild8            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579)];

   wild12            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612)];

   wild16            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643)];

   wild20            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643), Point(3340, 3652),
                        Point(3340, 3661), Point(3340, 3669),
                        Point(3340, 3677)];

   wild24            := [Point(3325, 3524),
                        Point(3328, 3532), Point(3330, 3539),
                        Point(3331, 3546), Point(3333, 3555),
                        Point(3334, 3562), Point(3333, 3571),
                        Point(3335, 3579), Point(3336, 3587),
                        Point(3339, 3595), Point(3336, 3605),
                        Point(3332, 3612), Point(3332, 3621),
                        Point(3333, 3627), Point(3334, 3635),
                        Point(3339, 3643), Point(3340, 3652),
                        Point(3340, 3661), Point(3340, 3669),
                        Point(3340, 3677), Point(3340, 3683),
                        Point(3340, 3692), Point(3340, 3701),
                        Point(3340, 3708)];

   wild0            := [Point(3340, 3708), Point(3340, 3701),
                        Point(3340, 3692), Point(3340, 3683),
                        Point(3340, 3677), Point(3340, 3669),
                        Point(3340, 3661), Point(3340, 3652),
                        Point(3339, 3643), Point(3334, 3635),
                        Point(3333, 3627), Point(3332, 3621),
                        Point(3332, 3612), Point(3336, 3605),
                        Point(3339, 3595), Point(3336, 3587),
                        Point(3335, 3579), Point(3333, 3571),
                        Point(3334, 3562), Point(3333, 3555),
                        Point(3331, 3546), Point(3330, 3539),
                        Point(3328, 3532), Point(3325, 3524)];

   case destination of
    "bankToCook": begin choosenTile := bankToCookTiles end;
    "geToBank": begin choosenTile := geToBankTiles end;
    "cookToBank": begin choosenTile := cookToBankTiles end;
    "bankToGe": begin choosenTile := bankToGETiles end;
    "cookWaterSpot": begin choosenTile := cookWaterSpot end;
    "cookExitSpot": begin choosenTile := cookExitSpot end;
    "lumbyToVarrock": begin choosenTile := lumbyToVarrock end;
    "bankToWild": begin choosenTile := bankToWild end;
    "wildToBank": begin choosenTile := wildToBank end;
    "bankToEast": begin choosenTile := bankToEast end;
    "eastToHouse": begin choosenTile := eastToHouse end;
    "houseRange": begin choosenTile := houseRange end;
    "houseDoorInside": begin choosenTile := houseDoorInside end;
    "houseToEast": begin choosenTile := houseToEast end;
    "eastToBank": begin choosenTile := eastToBank end;
    "tToFish": begin choosenTile := tToFish end;
    "tToFishGate": begin choosenTile := tToFishGate end;
    "tToChef": begin choosenTile := tToChef end;
    "tExitChef": begin choosenTile := tExitChef end;
    "tToQuest": begin choosenTile := tToQuest end;
    "tToMiningInstructor": begin choosenTile := tToMiningInstructor end;
    "tToMiningGate": begin choosenTile := tToMiningGate end;
    "tToRats": begin choosenTile := tToRats end;
    "tToBank": begin choosenTile := tToBank end;
    "tToPrayer": begin choosenTile := tToPrayer end;
    "tToMagic": begin choosenTile := tToMagic end;
    "bankToGrains": begin choosenTile := bankToGrains end;
    "grainsToCook": begin choosenTile := grainsToCook end;
    "grainExitSpot": begin choosenTile := grainExitSpot end;
    "grainEnterSpot": begin choosenTile := grainEnterSpot end;
    "wildToEast": begin choosenTile := wildToEast end;
    "wild0": begin choosenTile := wild0 end;
    "wild4": begin choosenTile := wild4 end;
    "wild8": begin choosenTile := wild8 end;
    "wild12": begin choosenTile := wild12 end;
    "wild16": begin choosenTile := wild16 end;
    "wild20": begin choosenTile := wild20 end;
    "wild24": begin choosenTile := wild24 end;
   end;

  reinitializeReflection;
  self.WalkPathMM(choosenTile, 0, 1, False);
  writelnex("endwalk " + destination);
  sleep(random(1200, 1600));
  reinitializeReflection(true);
  if not precise then Exit(True);
  tries := 0;
  while (self.Tile <> choosenTile[high(choosenTile)]) and (tries < 5) do
  begin
    writelnex('Final ' + destination + ' walk step');
    self.WalkToTileMS(choosenTile[high(choosenTile)]);
    Sleep(RandomRange(2000, 2500));
    inc(tries);
  end;
  reinitializeReflection(true);
  Result:=True;
end;

Function shouldSleep(minutes: int32): boolean;
begin
   Result := (CurrentSprintTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

Function shouldChangeAccount(minutes: int32): boolean;
begin
   Result := (CurrentAccountTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

Function shouldChangeSet(minutes: int32): boolean;
begin
   Result := (CurrentSetTimer.ElapsedTime >= (minutes * 60 * 1000));
end;

procedure checkCurrentResources(bankName: String = "Grand Exchange booth"; upText: String = "Bank Grand");
begin
  if not openClosestBank(bankName, 10, upText) then Exit;

  cShrimps  := R_FindBankItem(rawShrimpID).Amount  + R_CountInventoryItem(rawShrimpID);
  cTrouts   := R_FindBankItem(rawTroutID).Amount   + R_CountInventoryItem(rawTroutID);
  cSalmons  := R_FindBankItem(rawSalmonID).Amount  + R_CountInventoryItem(rawSalmonID);
  cHats     := R_FindBankItem(chefHatID).Amount    + R_CountInventoryItem(chefHatID);
  cBuckets  := R_FindBankItem(bucketID).Amount     + R_CountInventoryItem(bucketID);
  cPots     := R_FindBankItem(potID).Amount        + R_CountInventoryItem(potID);
  try
    cCoins    := R_FindBankItem(coinsID).Amount      + R_GetInventoryItem(coinsID)[0].Amount;
  Except
    cCoins    := R_FindBankItem(coinsID).Amount;
  end;

  if cShrimps = -1 then cShrimps  := 0;
  if cTrouts  = -1 then cTrouts   := 0;
  if cSalmons = -1 then cSalmons  := 0;
  if cHats    = -1 then cHats     := 0;
  if cBuckets = -1 then cBuckets  := 0;
  if cPots    = -1 then cPots     := 0;
  if cCoins   = -1 then cCoins    := 0;
end;

procedure withdrawGrandExchangeItems(buyGrains, sellPizzas: boolean);
begin
  openClosestBank("Grand Exchange booth", 10, "Bank Grand");

  R_DepositAll_Items;
  sleep(random(850,1050));
  if buyGrains then R_WithdrawItem(coinsID);
  sleep(random(1500,1850));
  if sellPizzas then
  begin
    R_SetBankWithdrawMode(True);
    sleep(random(50,150));
    R_WithdrawItem(pizzaBaseID);
    sleep(random(550,750));
    R_SetBankWithdrawMode(False);
  end;
  R_BankScreen_Close;
end;

procedure withdrawWildItems;
begin
  writelnex("Opening bank");
  if not openClosestBank("Grand Exchange booth", 10, "Bank Grand") then Exit;

  R_DepositAll_Items;
  sleep(random(50,150));
  R_DepositAll_Equipment;
  sleep(random(1550,1850));
  R_WithdrawItem(coinsID);
  sleep(random(550,850));
  R_BankScreen_Close;
end;

procedure depositGrains;
begin
  writelnex("Opening bank");
 if not openClosestBank then Exit;

  R_DepositAll_Items;
  sleep(random(1050,1350));
  R_WithdrawItem(coinsID);
  R_BankScreen_Close;
end;

procedure withdrawFlourToPizzaItems;
var
  currentPizzaBases: Integer;
  emptyPot, emptyBucket, grain, chefHat: TRSBankItem;
  chefHatInv: Array of TRSInventoryItem;
begin
  currentPizzaBases := R_CountInventoryItem(pizzaBaseID);
  pizzasDone += currentPizzaBases;

  writelnex("Opening bank");

  if not openClosestBank then Exit;

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(1200, 1500));
  totalPizzas := R_FindBankItem(pizzaBaseID).Amount;
  totalCoins := R_FindBankItem(coinsID).Amount;
  totalGrains := R_FindBankItem(grainID).Amount;

  emptyPot := R_FindBankItem(potID);
  grain := R_FindBankItem(grainID);
  emptyBucket := R_FindBankItem(bucketID);

  if (grain.id = -1) then
    pickWheat := True
  else
    pickWheat := False;

  grainsInBank := grain.Amount;

  if ((emptyPot.id = -1)) or ((emptyBucket.id = -1)) then
  begin
    writelnex("missing flourToPizza items (pot or bucket), TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  sleep(random(500,700));
  R_WithdrawItem(emptyPot.ID, 1);
  sleep(random(150,150));
  R_WithdrawItem(emptyBucket.ID, 1);
  sleep(random(150,150));
  if not R_IsEquipped(chefHatID) then
  begin
    chefHat := R_FindBankItem(chefHatID);
    if ((chefHat.id = -1)) then
    begin
      writeLnEx("Hat not equipped and not in bank, F");
      TerminateScript;
    end;
    R_WithdrawItem(chefHat.ID, 1);
    sleep(random(150,150));
  end;
  if isMillEmpty then
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 26)
  end else
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 10);
  end;
  sleep(random(350,150));
  R_BankScreen_Close;
  sleep(random(1000,1250));
  if not R_IsEquipped(chefHatID) then
  begin
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
    sleep(1000 + random(100, 200));
    chefHatInv := R_GetInventoryItem(chefHatID);
    if length(chefHatInv) > 0 then
      Mouse.Click(chefHatinv[0].midpoint, 2, MOUSE_LEFT)
    else
    begin
      writeLnEx("Hat not equipped and not in inv, F");
      TerminateScript;
    end;
    sleep(random(600,850));
  end;
end;

procedure cookFish;
var
  julietRange: RSObject;
  currentFishID, currentCookingLevel: Integer;
  timer: Timer;
begin
  julietRange := RSObject.Get(RSObjectType.GAME_OBJECT, 3238, 3409);
  if (julietRange.ref = nil) then
  begin
    writelnex("Range not found");
    julietRange.Free;
    Exit;
  end;
  player.walkTo("houseRange");
  sleep(random(500, 700));
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  while (R_CountInventoryItem(currentFishID) > 0) do
  begin
    AntibanAndBreak(false);
    writelnex('Using range');
    Mouse.Click(julietRange.MidPoint, MOUSE_LEFT);
    timer.Start;
    while(not R_ChatSkillOption(1)) do
    begin
      if timer.ElapsedTime >= 1000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;
    //sleep(random(1000,1100));
    writelnex("Choosing Option");
    R_ChatSkillChooseOptions(1);
    sleep(random(1000,1100));
    AntibanAndBreak(false);
    timer.Start;
    while (player.isAnimating) do
    begin
      if timer.ElapsedTime >= 35000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;
    AntibanAndBreak(false);
  end;
  julietRange.Free;

end;

procedure withdrawCookingItems;
var
  currentFishID, currentCookingLevel, currentFishes: Integer;
  currentFish: TRSBankItem;
begin
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  currentFishes := R_CountInventoryItem(currentFishID-2);
  fishesDone += currentFishes;

  if not openClosestBank then Exit;

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(800, 900));

  currentFish := R_FindBankItem(currentFishID);

  if (currentFish.id = -1) then
  begin
    writelnex("missing cook items, TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  R_WithdrawItem(currentFish.ID, 28);
  sleep(random(550,650));
  R_BankScreen_Close;
  sleep(random(600,850));
end;

Function grainsGate(enter: Boolean): Boolean;
var
  openGate, closedGate: RSObject;
  tries, gateTries:    Integer;
begin
  closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
  openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
  if (openGate.ref = nil) and (closedGate.ref = nil) then
  begin
    writelnex("Grain gates not found");
    Exit(False);
  end;
  tries := 0;
  gateTries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering grain field');
    if player.inGrains then
    begin
      writelnex('Already inside');
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;
    //player.WalkTo("grainEnterSpot");
    while not player.inGrains do
    begin
      if tries > 10 then
      begin
        openGate.Free;
        closedGate.Free;
        Exit(False);
      end;
      //if player.Tile.Y >= 3457 then Break;
      gateTries := 0;
      while (closedGate.ref <> nil) and (gateTries < 10) do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
        inc(gateTries);
      end;
      //sleep(random(2000,2500) + lag);
      inc(tries);
      player.WalkTo("grainExitSpot");
    end;
  end else
  begin
    writelnex('Leaving Grain field');
    if not player.InGrains then
    begin
      writelnex('Already outside');
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;
    player.WalkTo("grainExitSpot");
    while player.InGrains do
    begin
      if tries > 10 then Exit(False);
      //if player.Tile.Y < 3444 then Break;
      gateTries := 0;
      while (closedGate.ref <> nil) and (gateTries < 10) do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
        inc(gateTries);
      end;
      player.WalkTo("grainEnterSpot");
      //sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  openGate.Free;
  closedGate.Free;
  Result:=True;
end;

Function cookGuildDoor(enter: Boolean): Boolean;
var
  cookDoor: RSObject;
  tries:    Integer;
begin
  cookDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3143, 3443);
  if (cookDoor.ref = nil) then
  begin
    writelnex("CookDoor not found");
    Exit(False);
  end;
  tries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering Cooks Guild door');
    if player.InGuild then
    begin
      writelnex('Already inside');
      exit(True);
    end;
    while player.Tile <> Point(3143, 3444) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y >= 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000,2500) + lag);
      inc(tries);
    end;
  end else
  begin
    writelnex('Leaving Cooks Guild door');
    if not player.InGuild then
    begin
      writelnex('Already outside');
      exit(True);
    end;
    player.WalkTo("cookExitSpot");
    while player.Tile <> Point(3143, 3443) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y < 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  cookDoor.Free;
  Result:=True;
end;


Function rangeDoor(enter: Boolean): Boolean;
var
  rangeDoor: RSObject;
  tries:    Integer;
  rangeBox: TBox;
begin
  rangeDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412);
  tries := 0;
  rangeBox := Box(3236, 3409, 3241, 3416);
  //openCookDoor;
  if enter then
  begin
  if player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already inside');
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      exit(True);
    end;
    writelnex('Entering Range door');
    player.WalkTo("eastToHouse");
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000,1500));
      inc(tries);
    end;
    player.WalkTo("houseRange");
    sleep(random(500, 700));
  end else
  begin
    writelnex('Leaving Range door');
    if not player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already outside');
      player.WalkTo("houseToEast");
      sleep(random(1000,1500));
      exit(True);
    end;
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseToEast");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000, 1500));
      inc(tries);
    end;
    player.WalkTo("houseToEast");
  end;
  rangeDoor.Free;
  Result:=True;
end;

Function climbStairs(direction:String): Boolean;
var
  cookStairs: RSobject;
  startingFloor: Integer;
begin
  writelnex('Climbing Stairs ' + direction);
  cookStairs := RSObject.Get(RSObjectType.GAME_OBJECT, 3144, 3447);
  if (cookStairs.ref = nil) then
  begin
    writelnex("cookStairs not found");
    Exit(False);
  end;
  startingFloor := RSClient.plane;
  Mouse.Move(cookStairs.MidPoint.X + random(30), cookStairs.MidPoint.y + random(30) - 105);
  Wait(150 + RandomRange(50,100));
  Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
  Wait(50 + RandomRange(50, 100));
  R_ChooseOptions(['Climb-' + direction +' Staircase']);
  Wait(500 + RandomRange(50, 100));
  {while (startingFloor = RSClient.plane) and (tries < 10) do
  begin
    Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
    Wait(50 + RandomRange(50, 100));
    R_ChooseOptions(['Climb-' + direction +'  Staircase']);
    Wait(500 + RandomRange(50, 100));
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;}
  cookStairs.Free;
  Result := True;
end;

Function climbToFloor(floor: Integer): Boolean;
var
  tries: Integer;
begin
  writelnex('Climbing to floor '+ inttostr(floor));
  while (RSClient.Plane <> floor) and (tries < 10)  do
  begin
    if RSClient.Plane = floor then Exit(True);
    if RSClient.Plane > floor then climbStairs("down") else climbStairs("up");
    sleep(500 + random(200, 300) + lag);
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;
end;

Function emptyFlourPot:Boolean;
var
  flourPot: Array of TRSInventoryItem;
begin
  flourPot := R_GetInventoryItem(flourPotID);
  if (Length(flourPot) > 0) then
  begin
    Mouse.click(flourPot[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Pot of flour']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //flourPot.Free;
end;

Function emptyWaterBucket:Boolean;
var
  waterBucket: Array of TRSInventoryItem;
begin
  waterBucket := R_GetInventoryItem(waterBucketID);
  if (Length(waterBucket) > 0) then
  begin
    Mouse.click(waterBucket[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Bucket of water']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //waterBucket.Free;
end;

procedure makeFlourToPizza;
var
  hopper, hopperControl, cookMill, cookPump: RSObject;
  flourPot, waterBucket, emptyBucket: Array of TRSInventoryItem;
  i, fails, currentGrains, breakHopperCounter: Integer;
  timer: Timer;
begin
  loginPlayer;
  writelnex('Making flourToPizza!');
  AntibanAndBreak;
  fails := 0;

  //CheckMill;
  writelnex('Checking Mill');
  cookMill := RSObject.Get(RSObjectType.GAME_OBJECT, 3140, 3449);
  if (cookMill.ref = nil) then
  begin
    writelnex("cookMill not found");
    Exit;
  end;
  //TODO check if not at cook then die
  while (R_CountInventoryItem(pizzaBaseID) < 26) do
  begin
    if not LoginPlayer then Exit;
    ProgressReport;
    if (R_CountInventoryItem(grainID) < 1) then
    begin
      writelnex('Not going up because we aint got grains left');
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No flour on mill either, back to bank');
        isMillEmpty := True;
        Break;
      end;
    end else
    begin
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(random(500,700));
      emptyWaterBucket;
      ProgressReport;
      AntibanAndBreak;
      emptyFlourPot;
      climbToFloor(2);

      //third floor now
      writelnex('Filling Hopper');
      hopper := RSObject.Get(RSObjectType.GAME_OBJECT, 3142, 3452);
      if (hopper.ref = nil) then
      begin
        writelnex("hopper not found");
        Exit;
      end;
      Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
      //sleep(random(5000,3500));
      timer.Start;
      while(not player.Tile.Equals(Point(3142, 3451))) do
      begin
        if timer.ElapsedTime >= 5000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper at loop zero - if this keeps happening increase lag");
            Break;
          end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);
      AntibanAndBreak;
      ProgressReport;
      writelnex('Activating Hopper');
      hopperControl := RSObject.Get(RSObjectType.GAME_OBJECT, 3141, 3453);
      if (hopperControl.ref = nil) then
      begin
        writelnex("hopperControl not found");
        Exit;
      end;
      Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
      timer.Start;
      while(not player.Tile.Equals(Point(3141, 3452))) do
      begin
      if timer.ElapsedTime >= 5000 + lag then
        begin
          writeLnEx("At top floor - breaking hopperControl at loop zero - if this keeps happening increase lag");
          Break;
        end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);
      ProgressReport;
      currentGrains := R_CountInventoryItem(grainID);
      //TODO better check while shouldAddGrains do
      breakHopperCounter := 0;
      for i := 0 to 35 do
      begin
        ProgressReport;
        if (currentGrains < 1) then
        begin
          writelnEx("At top flor - No more grains");
          Break;
        end;
        if (i mod 10 = 0) then AntibanAndBreak;
        Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
        timer.Start;
        while(not (currentGrains <> R_CountInventoryItem(grainID))) do
        begin
          if timer.ElapsedTime >= 1000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper inside loop - if this keeps happening increase lag");
            break;
          end;
          Wait(50 + Random(50));
        end;
        timer.Reset;
        sleep(random(200,300) + lag);
        //sleep(random(1000,1500));
        Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
        //R_WaitFunction(1000, 100, currentGrains <> R_CountInventoryItem(grainID));
        sleep(random(1000,1500) + lag);
        if (currentGrains = R_CountInventoryItem(grainID)) then
        begin
          WriteLnEx(inttostr(breakHopperCounter) + "/ At top floor - Hopper seems full");
          if (breakHopperCounter > 7) then Break;
          inc(breakHopperCounter);
        end;
        currentGrains := R_CountInventoryItem(grainID);
      end;

      hopper.Free;
      hopperControl.Free;

    end;

    //climbDown;
    writelnex('Going down');
    climbToFloor(0);
    sleep(random(300,350));
    ProgressReport;
    //aca check mill antes

    player.walkTo("cookWaterSpot", True);
    timer.Start;
    while(not player.me.Tile.Equals(Point(3139, 3449))) do
    begin
      if timer.ElapsedTime >= 1800 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;

    //sleep(random(1500,2000));

    //CheckPump;
    writelnex('Checking Pump');
    cookPump := RSObject.Get(RSObjectType.GAME_OBJECT, 3138, 3449);
    if (cookPump.ref = nil) then
    begin
      writelnex("cookPump not found");
      Exit;
    end;

    //fill water, flour, make pizza, repeat

    while (R_CountInventoryItem(pizzaBaseID) < 26) do
    begin
      ProgressReport;
      //mill failsafe

      if fails > 3 then
      begin
        fails := 0;
        writelnex('Failing too much, bye');
        Break;
      end;

      if (Random(8) = 3) then AntibanAndBreak;

      //Check if inventory full but grains left
      if (R_InventoryCount > 27) AND (R_CountInventoryItem(grainID) > 1) then
      begin
        writelnex("Inventory full but still have grains left, going upstairs");
        Break;
      end;
      //fillWater
      if (R_CountInventoryItem(potID) <= 0) then
      begin
        writelnex("No empty pot");
        //Exit;
        Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
        sleep(random(500,700));
        if not emptyFlourPot then Exit;
      end;

      emptyBucket := R_GetInventoryItem(bucketID);
      if (Length(emptyBucket) <= 0) then
      begin
        writelnex("No empty bucket");
        //Exit;
        Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
        sleep(random(500,700));
        if not emptyWaterBucket then Exit;
        emptyBucket := R_GetInventoryItem(bucketID);
      end;
      sleep(random(150,200));
      Mouse.click(emptyBucket[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));

      Mouse.Click(cookPump.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(waterBucketID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      if (Random(10) = 3) then AntibanAndBreak;

      //sleep(random(1000,1000));

      //fill flour
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No more flour left');
        isMillEmpty := True;
        Break;
        inc(fails);
      end;
      ProgressReport;
      Mouse.Click(cookMill.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      if (Random(10) = 3) then AntibanAndBreak;
      //sleep(random(1000,1500));

      //makePizza
      waterBucket := R_GetInventoryItem(waterBucketID);
      flourPot := R_GetInventoryItem(flourPotID);
      if (Length(flourPot) <= 0) or (Length(waterBucket) <= 0) then
      begin
        writelnex("MISSING flourToPizza flourPot or waterBucket ITEMS, looping to se if we can empty some");
        Break;  // change to exit
      end;
      ProgressReport;
      Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));
      Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not R_ChatSkillOption(3)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(1000,1100));
      writelnex("Choosing Option");
      R_ChatSkillChooseOptions(3);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) = 0)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(500,700));
      if (R_CountInventoryItem(flourPotID) > 0) then
      begin
        writelnex('OptionFailsafe');
        Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
        sleep(random(50,100));
        Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
        sleep(random(800,900));
        R_ChatSkillChooseOptions(3);
        writelnex('Past failsafe');
        sleep(random(1500,2000));
      end
      if (Random(10) = 3) then AntibanAndBreak;

    end;
    cookPump.Free;

  end;

  writelnex('Full of pizza bases or no more flour left');
  isMillEmpty := (Length(cookMill.Model.Vertices) <> 316);
  cookMill.Free;
  //end floors repeat here
  //player.WalkToTileMS(Point(3143, 3446));
  //Mouse.Click(Point(6080, 6976), MOUSE_LEFT);
  //sleep(random(1000, 1500));

  //OutOfCook;
  //bank north booth 3186 3444

end;

procedure WheatProcedure;
var
  wheatObj: RSObject;
  tries, currentGrains: Integer;
  timer: Timer;
begin
  loginPlayer;
  AntibanAndBreak;
  grainsGate(true);
  AntibanAndBreak;
  if isMillEmpty then
  begin
    while (R_InventoryCount < 28)  and (tries < 50) do
    begin
      ProgressReport;
      inc(tries);
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      AntibanAndBreak;
    end;
  end else
  begin
    while (R_CountInventoryItem(GrainID) < 10) and (tries < 50) do
    begin
      ProgressReport;
      inc(tries);
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      AntibanAndBreak;
    end;
  end;
  wheatObj.Free;
  sleep(random(700, 1000));
  grainsGate(false);
end;

procedure grandExchange(buyGrains, sellPizzas: boolean);
begin
  if not player.inGE then Exit;
  withdrawGrandExchangeItems(buyGrains, sellPizzas);
  sleep(20);
  reinitializeReflection(true);
  sleep(20);
  if not openClosestExchange then Exit;
  if sellPizzas then sellCancelAndCollect("Pizza base", notedPizzaBaseID, currentPizzaPrice);
  if buyGrains then buyCancelAndCollect("Grain", 500, currentGrainPrice);
  countGrandExchangeItems;
  R_GrandExchangeScreen_Close;
end;

function calculateEstimatedCashNeeded: Integer;
begin
  Result += (150-cShrimps) * currentShrimpPrice;
  Result += (170-cTrouts)  * currentTroutPrice;
  Result += (170-cSalmons) * currentSalmonPrice;
  Result += (2-cHats)      * currentHatPRice;
  Result += (10-cBuckets)  * currentBucketPrice;
  Result += (10-cPots)     * currentPotPrice;
end;

function buyResources: Boolean;
var
  estimatedCashNeeded: Integer;
begin
  if not player.inGE then Exit(False);
  openClosestBank("Grand Exchange booth", 10, "Bank Grand");
  checkCurrentResources;
  estimatedCashNeeded := calculateEstimatedCashNeeded;

  writelnEx("Need " + inttostr(estimatedCashNeeded) + " Coins");
  if cCoins < estimatedCashNeeded then
  begin
    R_BankScreen_Close;
    writelnEx("Not enough coins, need " + inttostr(estimatedCashNeeded));
    Exit(False);
  end;
  withdrawCoins;
  sleep(random(1500, 2000));
  R_BankScreen_Close;
  sleep(random(500, 800));
  if not openClosestExchange then Exit(False);
  sleep(random(1200, 1500));
  if cShrimps < 150 then buyCancelAndCollect("Raw shrimps", 150 - cShrimps, currentShrimpPrice);
  if cTrouts  < 170 then buyCancelAndCollect("Raw trout",   170 - cTrouts,  currentTroutPrice);
  if cSalmons < 170 then buyCancelAndCollect("Raw salmon",  170 - cSalmons, currentSalmonPrice);
  if cHats    < 2   then buyCancelAndCollect("Chef's hat",  2   - cHats,    currentHatPrice);
  if cBuckets < 10  then buyCancelAndCollect("Bucket",      10  - cBuckets, currentBucketPrice);
  if cPots    < 10  then buyCancelAndCollect("Pot",         10  - cPots,    currentPotPrice);
  buyCancelAndCollect("Grain", (R_GetInventoryItem(coinsID)[0].Amount div currentGrainPrice), currentGrainPrice);
  R_GrandExchangeScreen_Close;
  Result := True;
end;

procedure flourToPizzaProcedure;
begin
  if player.inGrains then
  begin
    writelnEx("inGrains");
    wheatProcedure;
    player.WalkTo("grainsToCook");
    sleep(random(700, 1000));
    AntibanAndBreak;
  end;
  if player.InGuild then
  begin
    loginPlayer;
    writelnEx("InGuild");
    climbToFloor(0);
    makeFlourToPizza;
    cookGuildDoor(False);
    AntibanAndBreak;
  end else
  begin
    if (R_CountInventoryItem(grainID) > 0) and (R_CountInventoryItem(PotID) > 0) and (R_CountInventoryItem(BucketID) > 0) then
    begin
      writelnEx("NotInGuild - bankToCook");
      player.walkTo("bankToCook");
      //sleep(random(700, 1000));
      cookGuildDoor(True);
      //sleep(random(700, 1000));
    end else
    begin
      writelnEx("NotInGuild - cookToBank");
      player.walkTo("cookToBank");
      //sleep(random(700, 1000));
      Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
      sleep(random(500,700));
      if emptyWaterBucket then sleep(random(700, 1000));
      if emptyFlourPot then ;sleep(random(700, 1000));
      sleep(random(700, 1000));
      withdrawFlourToPizzaItems;
      ProgressReport;
      if ((timeSinceLastGeVisit.ElapsedTime > (60 * 60 * 1000)) or ((runs < 1) and GEonFirstRun)) and useGe then
      begin
        reinitializeReflection;
        writelnEx("DOING GE");
        inc(geVisits);
        timeSinceLastGeVisit.Reset;
        timeSinceLastGeVisit.Start;
        player.WalkTo("bankToGe");
        sleep(random(700, 1000));
        if (grainsInBank < 2000) then
        begin
          WriteLnEx('GE: GrainsAndPizza, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(true, true);
        end else
        begin
          WriteLnEx('GE: PizzaOnly, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(false, true);
        end;
        sleep(random(700, 1000));
        player.WalkTo("geToBank");
        Exit;
      end;
      sleep(random(700, 1000));
      if pickWheat then
      begin
        player.WalkTo("bankToGrains");
        sleep(random(700, 1000));
        wheatProcedure;
        player.WalkTo("grainsToCook");
        sleep(random(700, 1000));
      end;
    end;
  end;
end;

procedure muleItems;
var
  webMuleMessage: TWebMessage;
  tries, desiredWildLevel: Integer;
  widget: RSWidget;
Label
  alreadyInDitch;
begin
  writelnEx("MuleItems");
  if not LoginPlayer then Exit;

  setBotWebMessage(player.Name, 'request mule', player.CombatLevel);
  writelnex("MI2");

  webMuleMessage := getMuleWebMessage;
  writelnex("MI3");
  if not isMuleMessage("available", 5, player.Name) then
  begin
    WritelnEx("Mule not available");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;
  writelnex("MI4");

  if player.inWildDitch then
    GoTo alreadyInDitch;

  setBotWebMessage(player.Name, 'getting gold', player.CombatLevel);

  if not player.inGE then
  begin
    if player.InGuild then
    begin
      writelnEx("InGuild");
      climbToFloor(0);
      cookGuildDoor(False);
    end;
    player.WalkTo("cookToBank");
    player.WalkTo("bankToGe");
  end;

  reinitializeReflection;
  grandExchange(false, true);   //sell pizzas
  sleep(Random(1500,3000));
  withdrawWildItems;
  sleep(Random(1500,3000));
  if (High(R_GetInventoryItem(coinsID)) < 0) or (R_GetInventoryItem(coinsID)[0].Amount < 1) then
  begin
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;

  setBotWebMessage(player.Name, 'going to wild border', player.CombatLevel);

  writelnEx("Waiting for Mule to start going to border");
  if not isMuleMessage(["going to wild border", "arrived at wild border"], 30, player.Name) then
  begin
    writelnEx("Mule is not going to wild border");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    Exit;
  end;
  player.WalkTo("geToBank");
  player.WalkTo("bankToWild");
  reinitializeReflection;
  sleep(Random(1500,3000));

  AlreadyInDitch:
  setBotWebMessage(player.Name, 'arrived at wild border', player.CombatLevel);

  writelnEx("Waiting for Mule to arrive at border");
  if not isMuleMessage(["arrived at wild border", "crossed ditch", "arrived at wild level"], 150, player.Name) then
  begin
    writelnEx("Mule never arrived at wild border");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wildToBank");
    Exit;
  end;

  webMuleMessage := getMuleWebMessage;
  desiredWildLevel := abs(player.CombatLevel - webMuleMessage.combat);
  WritelnEx("should walk til wild lvl " + IntToStr(desiredWildLevel));

  Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);
  sleep(Random(1000,1500));
  widget := RSWidget.Get(R_COMBAT_RETALIATE_TEXT.group, R_COMBAT_RETALIATE_TEXT.child);
  if widget.ref <> nil then
  begin
    if pos("On",widget.Text) > 0 then
      Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
    sleep(500);
    widget.Free;
  end;

  writelnEx("Crossing ditch");
  if not CrossDitch(true) then
  begin
    WritelnEx('Couldnt cross ditch');
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wildToBank");
    Exit;
  end;

  setBotWebMessage(player.Name, 'crossed ditch', player.CombatLevel);

  writelnEx("Waiting for Mule to cross ditch");
  if not isMuleMessage(["crossed ditch", "arrived at wild level"], 30, player.Name) then
  begin
    writelnEx("Mule never crossed the ditch");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    crossDitch(false);
    player.WalkTo("wildToBank");
    Exit;
  end;

  case desiredWildLevel of
    0..3: begin player.WalkTo("wild4") end;
    4..7: begin player.WalkTo("wild8") end;
    8..11: begin player.WalkTo("wild12") end;
    12..15: begin player.WalkTo("wild16") end;
    16..19: begin player.WalkTo("wild20") end;
    20..23: begin player.WalkTo("wild24") end;
    else begin WritelnEx('mucha diff') end;
  end;

  reinitializeReflection;
  setBotWebMessage(player.Name, 'arrived at wild level', player.CombatLevel);

  writelnEx("Waiting for Mule to arrive at wild level");
  if not isMuleMessage("arrived at wild level", 30, player.Name) then
  begin
    writelnEx("Mule never arrived at wild level");
    setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToBank");
    Exit;
  end;

  for tries := 0 to 5 do
  begin
    if attackPlayer(webMuleMessage.name) then
    begin
      setBotWebMessage(player.Name, 'attacked', player.CombatLevel);
      sleep(Random(1500, 2500));
      player.WalkToTileMM(player.Tile, 2, 2);
      break;
    end;
    if tries > 4 then
    begin
      writelnEx("Could not attack mule");
      setBotWebMessage(player.Name, 'cancel', player.CombatLevel);
      player.WalkTo("wild0");
      crossDitch(false);
      player.WalkTo("wildToBank");
      Exit;
    end;
    inc(tries);
  end;
end;

procedure muleProcedure;
var
  webBotMessage: TWebMessage;
  tries, desiredWildLevel: Integer;
  widget: RSWidget;
  coinsArray: Array of RSTile;
begin
  WritelnEx("Starting mule procedure");
  LoginPlayer;

  player.WalkTo("geToBank");
  player.WalkTo("bankToEast");
  player.WalkTo("wildToEast");

  if (not isBotMessage(["request mule","getting gold", "going to wild border"], 30)) then
    LogoutPlayer;

  writelnEx("Waiting for Bot to start going to border");
  for tries := 0 to 50 do
  begin
    if isBotMessage(["request mule", "getting gold", "going to wild border"], 1) then
    begin
      webBotMessage := getBotWebMessage;
      setMuleWebMessage(player.Name, 'available', webBotMessage.target, player.CombatLevel);
      if not LoginPlayer then
      begin
        setMuleWebMessage("", 'cancel', webBotMessage.target, 0);
        Exit;
      end;
      setMuleWebMessage(player.Name, 'going to wild border', webBotMessage.target, player.CombatLevel);
      Break;
    end;
    sleep(10000);
  end;

  if tries > 49 then
  begin
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    Exit;
  end;

  player.WalkTo("bankToWild");
  setMuleWebMessage(player.Name, 'arrived at wild border', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to arrive at border");
  if not isBotMessage(["arrived at wild border", "crossed ditch"], 150) then
  begin
    writelnEx("Bot never arrived at wild border");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wildToEast");
    Exit;
  end;

  webBotMessage := getBotWebMessage;
  desiredWildLevel := abs(player.CombatLevel - webBotMessage.combat);
  WritelnEx("should walk til wild lvl " + IntToStr(desiredWildLevel));

  Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);
  sleep(Random(1000,1500));
  widget := RSWidget.Get(R_COMBAT_RETALIATE_TEXT.group, R_COMBAT_RETALIATE_TEXT.child);
  if widget.ref <> nil then
  begin
    if pos("Off",widget.Text) > 0 then
      Mouse.Click(widget.Bounds.Middle, 5, MOUSE_LEFT);
    sleep(500);
    widget.Free;
  end;

  writelnEx("Crossing Ditch");
  if not CrossDitch(true) then
  begin
    WritelnEx('Couldnt cross ditch');
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wildToEast");
    Exit;
  end;

  setMuleWebMessage(player.Name, 'crossed ditch', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to cross ditch");
  if not isBotMessage(["crossed ditch", "arrived at wild level"], 30) then
  begin
    writelnEx("Bot never crossed the ditch");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  case desiredWildLevel of
    0..3: begin player.WalkTo("wild4") end;
    4..7: begin player.WalkTo("wild8") end;
    8..11: begin player.WalkTo("wild12") end;
    12..15: begin player.WalkTo("wild16") end;
    //16..19: begin player.WalkTo("wild20") end;
    //20..23: begin player.WalkTo("wild24") end;
    else begin WritelnEx('mucha diff') end;
  end;

  setMuleWebMessage(player.Name, 'arrived at wild level', webBotMessage.target, player.CombatLevel);

  writelnEx("Waiting for Bot to arrive at wild level");
  if not isBotMessage(["arrived at wild level", "attacked"], 30) then
  begin
    writelnEx("Bot never arrived at wild level");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  writelnEx("Waiting for Bot to attack us");
  if not isBotMessage("attacked", 30) then
  begin
    writelnEx("Bot never attacked");
    setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
    player.WalkTo("wild0");
    crossDitch(false);
    player.WalkTo("wildToEast");
    Exit;
  end;

  sleep(Random(1500, 2000));

  tries := 0;
  while tries < 120 do
  begin
    if not attackPlayer(webBotMessage.name) then
    begin
      WritelnEx("Bot is not here, maybe dead?");
      coinsArray := R_GetMainscreenGroundItemByID(995);
      while High(coinsArray) > -1 do
      begin
        Mouse.Move(0, 0);
        Mouse.Click(coinsArray[0], MOUSE_RIGHT);
        sleep(Random(100,200));
        if R_ChooseOptions(['ake Coin']) then
        begin
          sleep(Random(1000,1500));
        end;
        coinsArray := R_GetMainscreenGroundItemByID(995);
      end;
      WritelnEx("No more coins");

      if not isPlayerVisible(webBotMessage.name) then
      begin
        WritelnEx("No more coins or player, bye");
        setMuleWebMessage(player.Name, 'cancel', webBotMessage.target, player.CombatLevel);
        player.WalkTo("wild0");
        crossDitch(false);
        player.WalkTo("wildToEast");
        if player.inEastBank then
        begin
          openClosestBank;
          R_DepositAll_Items;
          sleep(random(1000,1500));
          R_BankScreen_Close;
        end;
        Exit;
      end;
    end;
    sleep(Random(800,1200));
    inc(tries);
  end;
end;

procedure cookingProcedure;
begin
  while (player.me.SkillLevel(7) < 32) do
  begin
    rangeDoor(False);
    AntibanAndBreak;
    sleep(random(700, 1000));
    player.walkTo("bankToEast");
    sleep(random(700, 1000));
    player.walkTo("houseToEast");
    sleep(random(700, 1000));
    withdrawCookingItems;
    progressReport;
    AntibanAndBreak;
    sleep(random(700, 1000));
    player.walkTo("eastToHouse");
    sleep(random(700, 1000));
    rangeDoor(True);
    sleep(random(700, 1000));
    cookFish;
    if player.me.SkillLevel(7) >= 32 then
    begin
      writelnex("Already at 32 cooking, bye");
      progressReport;
      rangeDoor(False);
      player.WalkTo("eastToBank");
      Exit;
    end;
  end;
end;

procedure keepAliveProcedure;
begin
  player.walkToTileMM(startPos, -10, 10);
  wait(60000 + random(5000, 30000));
end;

procedure wildProcedure;
begin
  if player.InGuild then
  begin
    writelnEx("InGuild");
    climbToFloor(0);
    cookGuildDoor(False);
  end;
  player.walkto("cookToBank");
  sleep(random(700, 1000));
  withdrawWildItems;
  player.WalkTo("bankToGe");
  sleep(random(700, 1000));
  WritelnEx("Not selling pizzas, do it yourself");
  depositGrains;
  writelnEx('deposited');
  player.WalkTo("geToBank");
  sleep(random(700, 1000));
  player.WalkTo("bankToWild");
  sleep(random(700, 1000));
  TerminateScript;
end;

procedure hybridProcedure;
begin
  AntibanAndBreak;
  if R_InTutorialIsland then
  begin
    writelnEx("InTutIsland");
    R_TutorialIsland("");
  end;

  if player.InLumby then
  begin
    writelnEx("InLumby");
    player.walkTo("lumbyToVarrock");
  end;

  if player.InGE then
  begin
    writelnEx("InGE");
    player.walkTo("geToBank");
  end;

  if player.me.SkillLevel(7) < 32 then
  begin
    writelnex("Getting that cooking up");
    AntibanAndBreak;
    if player.inEastBank then
    begin
      checkCurrentResources("Bank booth", "Bank Bank");
      if (cShrimps > 2) or (cTrouts > 2) or (cSalmons > 2) then
        cookingprocedure;
    end;

    if player.inWestBank then
    begin
      if tradeMode then
      begin
        acceptTrade;
      end else
      begin
        checkCurrentResources("Bank booth", "Bank Bank");
        if (cShrimps < 150) or (cTrouts < 170) or (cSalmons < 170) then
        begin
          if cCoins < calculateEstimatedCashNeeded then
          begin
            //shouldRunOneOff := false;
            tradeMode := true;
            writelnEx('No cooking level, no fish in bank, and no money, halt until we get dem fishes');
            //acceptTradesMode
            player.walkToTileMM(Point(3184, 3438), -3, 3);
            sleep(random(2000,4000));
            Exit;
          end else
          begin
            player.walkTo('bankToGe');
            AntibanAndBreak;
            buyResources;
            player.WalkTo('geToBank');
            openClosestBank;
            R_DepositAll_Items;
            sleep(random(1000,1500));
            R_BankScreen_Close;
          end;
        end else
          cookingProcedure;
      end;
    end;
  end else
  begin
   flourToPizzaProcedure;
  end;
end;

procedure testProcedure;
var
  obj: RSObject;
  groundItem: Array of RSTile;
  allNpcs: Array of RSNPC;
  widget: RSWidget;
  testPoint: TPoint;
  Messages: Array of TRSChatMessage;
  j: Integer;
begin
  writeln("testing");
  //setMuleWebMessage('franehr007', 'cancel', 18);
  while true do
  begin
    groundItem := R_GetMainscreenGroundItemByID(995);
    if High(groundItem) > -1 then
    begin
      Mouse.Click(groundItem[0], 3, MOUSE_RIGHT);
      sleep(Random(100,200));
      if R_ChooseOptions(['ake Coin']) then
      begin
        sleep(Random(1000,1500));
      end;
      groundItem := R_GetMainscreenGroundItemByID(995);
    end;
    WritelnEx("No more coins");
    sleep(3000);
    cleardebug;
  end;
  TerminateScript;
  writeln(R_BankScreen);
  writeln(R_BankHelp);
  openClosestBank();
  sleep(3000);
  //writeln(RSClient.GetVarBit(281));
  writeln(RSVarps.VarpMain(281));
  //obj := R_GetClosestObjectByName("Bank chest");
    //obj := RSObject.Get(GAME_OBJECT, 1948,4956);
  //Mouse.Click(obj.MidPoint, 3, MOUSE_LEFT);
  //terminatescript;
end;

label TryAgain;

procedure setLoop
begin
  currentAccountTimer.Reset;
  currentAccountTimer.Start;
  while not shouldChangeAccount(accountMinutes) do
  begin
    TryAgain:
    timeSinceLastGeVisit.Reset;
    timeSinceLastGeVisit.Start;
    currentSprintTimer.Reset;
    currentSprintTimer.Start;
    webPlayer := getWebPlayer(currentSet);
    if (P_USERNAME <> "") and (P_PASSWORD <> "") then
    begin
      currentUser := P_USERNAME;
      currentPassword := P_PASSWORD;
    end else
    if (webPlayer.email <> "") and (webPlayer.password <> "") and (not webPlayer.online) then
      begin
        currentUser := webPlayer.email;
        currentPassword := webPlayer.password;
    end else
    begin
      WritelnEx("No USER set and can't get one from the site [ScriptID:"+ScriptID[currentSet]+"], sleeping 5 min and retrying", true);
      SleepAndPrintProgressReport(5 * 60 * 1000, @ProgressReport);
      if shouldChangeSet(setMinutes + Random(randomSetMinutes)) then Exit;
      goto TryAgain;
    end;

    while True do
    begin
      Try
        if scriptID[currentSet] <> "" then webScript := getWebScript;
        writeln(webScript);
        if isWebActionValid(webScript.action) then
        begin
          if action <> webScript.action then shouldRunOneOff := True;
          action              := webScript.Action;
          currentGrainPrice   := webScript.grainPrice;
          currentPizzaPrice   := webScript.pizzaPrice;
          currentShrimpPrice  := webScript.shrimpPrice;
          currentTroutPrice   := webScript.troutPrice;
          currentSalmonPrice  := webScript.salmonPrice;
          currentHatPrice     := webScript.hatPrice;
          currentPotPrice     := webScript.potPrice;
          currentBucketPrice  := webScript.bucketPrice;
        end else
        begin
          action              := userAction;
          currentGrainPrice   := GRAIN_PRICE;
          currentPizzaPrice   := PIZZA_PRICE;
          currentShrimpPrice  := SHRIMP_PRICE;
          currentTroutPrice   := TROUT_PRICE;
          currentSalmonPrice  := SALMON_PRICE;
          currentHatPrice     := HAT_PRICE;
          currentPotPrice     := POT_PRICE;
          currentBucketPrice  := BUCKET_PRICE;
        end;

        player.Free;
        progressReport;
        if shouldChangeSet(setMinutes + Random(randomSetMinutes)) then
        begin
          logoutPlayer;
          Exit;
        end;
        if shouldChangeAccount(accountMinutes + Random(randomAccountMinutes)) then
        begin
          logoutPlayer;
          Break;
        end;
        if (not loginPlayer) then goto TryAgain;
        currentBaseX := RSCLient.BaseX;
        currentBaseY := RSCLient.basey;
        currentPlane := RSCLient.Plane;
        player := RSPlayer.Me;
        startPos := player.Tile;
        player.ToggleRun(True);

        case action of
          "keepAlive": begin keepAliveProcedure end;
          "doTest":   begin testProcedure; end;
          "doMule":   begin muleProcedure; end;
          "doBotMule":   begin muleItems; end;
          "doWild":   begin wildProcedure; end;
          "hybrid":   begin if shouldRunOneOff then hybridProcedure end;
          "walkToGe":   begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            player.WalkTo("bankToGe");
                          end;
                        end;
          "walkToBank":   begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            writeln('a');
                            player.WalkTo("geToBank");
                            writeln('b');
                          end;
                        end;
          "walkToWild":  begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            if player.InLumby then
                            begin
                              writelnEx("InLumby");
                              player.walkTo("lumbyToVarrock");
                            end;

                            if player.InGuild then
                            begin
                              writelnEx("InGuild");
                              climbToFloor(0);
                              cookGuildDoor(False);
                            end;
                            player.WalkTo("cookToBank");
                            player.WalkTo("geToBank");
                            player.WalkTo("bankToWild");
                          end;
                        end;
          "sellPizzas": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            grandExchange(false, true);
                          end;
                        end;
          "buyGrains": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            grandExchange(true, false);
                          end;
                        end;
          "buyResources": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            buyResources;
                          end;
                        end;
          "withdrawWildItems": begin
                          if not shouldRunOneOff then
                          begin
                            writelnEx('No new action, sleeping', true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                          end else
                          begin
                            shouldRunOneOff := false;
                            withdrawWildItems;
                          end;
                        end;
          "pause":      begin
                          writeLnEx("PAUSE", true);
                            SleepAndPrintProgressReport(10 * 1000, @ProgressReport);
                        end;
          else
          begin
            WriteLnEx("NO VALID ACTION FOUND", true);
            TerminateScript;
          end;
        end;
        inc(runs);
        reinitializeReflection;
      Except
        //E: Exception do writelnex("ERROR "+ E.message);
        progressReport;
        WriteLnEx(GetExceptionMessage, true);
      end;
    end;
    player.Free;
  end;
  writelnEx('Switching to new account', true);

end;

procedure nextSet;
var
  maxSets: Integer;
begin
  maxSets := High(ScriptID);
  inc(currentSet);
  if currentSet > maxSets then
    currentSet := 0;
end;

procedure workbitch;
begin
  currentSet := 0;
  {SetLength(ScriptID, Length(Scripts));
  ScriptID := Scripts;
  if (High(ScriptID) < 0) then
  begin
    SetLength(ScriptID, 1);
    ScriptID[currentSet] := "";
  end;   }
  timerTrack.Start;
  startTime := Now;
  antibanMark.Start;
  pizzasDone := 0;
  floursDone := 0;
  geVisits := 0;
  pickWheat := True;
  sellPizzas := False;
  runs := 0;
  ClearDebug;
  shouldRunOneOff := true;
  setupDrawing;
  while True do
  begin
    currentSetTimer.Reset;
    currentSetTimer.Start;
    while not ShouldChangeSet(setMinutes) do
    begin
      setLoop;
    end;
    WritelnEx("Switching to next set");
    nextSet;
  end;
end;
