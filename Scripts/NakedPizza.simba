{$i reflection/reflection.simba}                      
{$include_once reflection/GrandExchange.simba}

// SET "REMEMBER USERNAME" TO FALSE!!!!!!!!!!!
const
  userAction  = "hybrid"; //hybrid, doWild, keepAlive
  actionWeb   = "http://franher.com/nakedpizza";
  scriptID    = "";
  useGE       = True;    //Buy/Sell in Grand Exchange?
  lag         = 0;     //use 0 if you have faster cpu speeds, increase for shitty pc

  P_USERNAME = "";
  P_PASSWORD = "";

  PIZZA_PRICE  = 350;
  GRAIN_PRICE  = 35;

  flourPotID =  1933;
  coinsID = 995;
  waterBucketID = 1929;
  potID = 1931;
  bucketID = 1925;
  pizzaBaseID = 2283;
  grainID = 1947;
  chefHatID = 1949;

  rawShrimpID = 317;
  rawTroutID = 335;
  rawSalmonID = 331;

  notedFlourPotID =  1934;
  notedWaterBucketID = 1930;
  notedPotID = 1932;
  notedBucketID = 1926;
  notedPizzaBaseID = 2284;
  notedGrainID = 1948;

type
  TWebPlayer = record
  email, password, user, action, scriptId: String;
  active, online: Boolean;
  end;

type
  TWebScript = record
  action: String;
  ID, pizzaPrice, grainPrice: Integer;
  end;


var
  pizzasDone, runs, floursDone, fishesDone, geVisits      : Integer;
  timerTrack                        : Timer;
  timeSinceLastGeVisit              : Timer;
  startTime                         : TDateTime;
  isMillEmpty                       : Boolean;
  player                            : RSPlayer;
  startPos                          : TPoint;
  pickWheat                         : Boolean;
  sellPizzas                        : Boolean;
  action                            : String;
  currentUser                       : String;
  currentPassword                   : String;
  currentGrainPrice                 : Integer;
  currentPizzaPrice                 : Integer;
  webPlayer                         : TWebPlayer;
  webScript                         : TWebScript;
  grainsInBank                      : Integer;
  shouldRunOneOff                   : Boolean;

Procedure writelnex(text: String);
begin
  writeln("[0]["+player.name+"]: " + text);
end;

procedure ProgressReport;
begin
  writelnex('##########  PROGRESS  ##########');
  writelnex('## CURRENT TIME: ' + FormatDateTime('hh:nn:ss',now));
  writelnex('## Time Running: ' + FormatDateTime('hh:nn:ss',now-startTime));
  writelnex('## RUNS        : ' + intToStr(runs));
  writelnex('## Flours      : ' + intToStr(floursDone));
  writelnex('## Pizzas      : ' + intToStr(pizzasDone));
  writelnex('## Fishes      : ' + intToStr(fishesDone));
  writelnex('## GE VISITS   : ' + intToStr(geVisits));
  writelnex('## -------  PER HOUR  ------- ##');
  writelnex('## RUNS        : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * runs)));
  writelnex('## Flours      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * floursDone)));
  writelnex('## Pizzas      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * pizzasDone)));
  writelnex('## Fishes      : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * fishesDone)));
  writelnex('## GE visits   : ' + inttostr( Round(60 / (GetTimeRunning/1000/60) * geVisits)));
  writelnex('################################');
  writelnex('GTR: ' + inttostr(GetTimeRunning));
  writelnex('TSLGEV: ' + inttostr(TimeSinceLastGeVisit.ElapsedTime));
end;

Function RSObject.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function RSNPC.MidPoint: TPoint;
var
  model: RSModel;
  triangles: Array of T2DTriangle;
  points: TPointArray;
  i: Int32;
begin
  model := self.Model;
  triangles := model.Project(localtile.X, localtile.Y, localtile.GetHeight(), -1);
  model.Free;

  for i := 0 to high(triangles) do
  begin
    points += triangles[i].A;
    points += triangles[i].B;
    points += triangles[i].C;
  end;

  Result := MiddleTPA(points);
end;

Function TRSInventoryItem.MidPoint: TPoint;
begin
  Result := self.Bounds.Middle;
end;

function TileOnMM(Tile: RSTile; radius: integer = 0): Boolean;
var
  W, H, MMCX, MMCY: Int32;
  Temp: TPointArray;
begin
  GetClientDimensions(W, H);
  if RSClient.IsResizeable then
  begin
    MMCX := (W - 82);   //From RSTile.
    MMCY := 84;
  end else
    begin
      MMCX := (W - 122);
      MMCY := 84;
    end;

  SetLength(Temp, 1);
  Temp[0] := Tile.ToLocal.TileToMM;
  FilterPointsPie(Temp, 0.0, 360.0, 0.0, 76.0 - radius, MMCX, MMCY);
  Result := Length(Temp) = 1;
end;

{$IFNDEF CODEINSIGHT}
    {*Credit JuKKa*}
function WindPath(Xs, Ys, Xe, Ye, Gravity, Wind, MaxStep, TargetArea: Extended): TPointArray;
var
  VeloX, VeloY, WindX, WindY, VeloMag, Dist, RandomDist, LastDist: Extended;
  Step, Sqrt2, Sqrt3, Sqrt5: Extended;
  LastX, LastY: Integer;
begin
  Sqrt2:= Sqrt(2);
  Sqrt3:= Sqrt(3);
  Sqrt5:= Sqrt(5);
  while Hypot(Xs - Xe, Ys - Ye) > 1 do
  begin
    Dist:= hypot(Xs - Xe, Ys - Ye);
    Wind:= Min(Wind, Dist);
    if Dist >= TargetArea then
    begin
      WindX:= WindX / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
      WindY:= WindY / Sqrt3 + (Random(Round(Wind) * 2 + 1) - Wind) / Sqrt5;
    end else
    begin
      WindX:= WindX / Sqrt2;
      WindY:= WindY / Sqrt2;
      if (MaxStep < 3) then
        MaxStep:= random(3) + 3.0
      else
        MaxStep:= MaxStep / Sqrt5;
    end;
    VeloX:= VeloX + WindX;
    VeloY:= VeloY + WindY;
    VeloX:= VeloX + Gravity * (Xe - Xs) / Dist;
    VeloY:= VeloY + Gravity * (Ye - Ys) / Dist;
    if Hypot(VeloX, VeloY) > MaxStep then
    begin
      RandomDist:= MaxStep / 2.0 + random(0, (round(MaxStep) div 2));
      VeloMag:= sqrt(VeloX * VeloX + VeloY * VeloY);
      VeloX:= (VeloX / VeloMag) * RandomDist;
      VeloY:= (VeloY / VeloMag) * RandomDist;
    end;
    LastX:= Round(Xs);
    LastY:= Round(Ys);
    Xs:= Xs + VeloX;
    Ys:= Ys + VeloY;
    SetArrayLength(Result, GetArrayLength(Result) + 1);
    Result[High(Result)] := Point(Round(Xs), Round(Ys));
    Step:= Hypot(Xs - LastX, Ys - LastY);
    LastDist:= Dist;
  end;
end;
{$ENDIF}

function RSPlayer.WalkToTileMM(Tile: RSTile; randomFrom: Integer = 0; randomTo: Integer = 0): Boolean;
var
  Point: TPoint;
begin
  Result := False;
  if not TileOnMM(Tile) then
  begin
    Exit;
  end;

  Point := Tile.ToLocal.TileToMM;
  Mouse.Move(Point.X + randomRange(randomFrom, randomTo), Point.Y + randomRange(randomFrom, randomTo));
  Wait(RandomRange(150, 220));
  Mouse.Click(MOUSE_LEFT);
  Result := True;
end;

function RSPlayer.WalkToTileMS(Tile: RSTile): Boolean;
var
  Point: TPoint;
begin
  Result := False;

  Point := Tile.ToLocal.TileToMS;
  Mouse.Move(Point);
  Wait(RandomRange(150, 220));
  Mouse.Click(MOUSE_LEFT);
  Result := True;
end;

function RSPlayer.FFlag(
  TileDist: Integer = 0; Timeout: Integer = -1): Boolean;
var
  Timer, StuckTimer: Int64;
  PrevTile, MyDest, MyTile : RSTile;
begin
  Timer := GetTickCount();
  StuckTimer := GetTickCount();

  MyTile := Self.Tile;
  PrevTile := MyTile;
  MyDest := Self.Destination;

  while Distance(MyTile.X, MyTile.Y, MyDest.X, MyDest.Y) > TileDist do
  begin
    if (Timeout > 0) and ((GetTickCount() - Timer) > Timeout) then
      Exit(False);

    if (GetTickCount() - StuckTimer) > 800 then
    begin
      if (MyTile.X = PrevTile.X) and (MyTile.Y = PrevTile.Y) then
        Exit(false);
      StuckTimer := GetTickCount();
      PrevTile := MyTile;
    end;

    Wait(RandomRange(200, 250));

    MyTile := Self.Tile;
    MyDest := Self.Destination;
  end;

  Exit(True);
end;

function RSPlayer.WalkPathMM(Path: array of RSTile; Randomness, FlagDist: Integer; Inverted: Boolean): Boolean;
var
  Index, Timer, Tries: Int64;
begin
  if Inverted then InvertTPA(Path);
  while Distance(Path[High(Path)], self.Tile) > (FlagDist + Randomness + 1) do
  begin
    for Index := High(Path) downto 0 do
      if TileOnMM(Path[Index]) then
        Break;
    if (Index = -1) then
      Break;
    Wait(800 + Random(100));
    if WalkToTileMM(Path[Index]) then
    begin
      Timer := (GetTickCount() + 5000);
      while Distance(Path[Index], self.Tile) > FlagDist do
      begin
        Wait(500 + Random(100));
        if Distance(Path[High(Path)], self.Tile) <= (FlagDist + Randomness + 1) then Break;
        if (GetTickCount() > Timer) or ((Index <> High(Path)) and (TileOnMM(Path[Index+1], 5))) then
          Break;
      end;
      if (GetTickCount() > Timer) then Inc(Tries);

      if (not (Distance(Path[Index], self.Tile) <= 5)) and ((Index <> High(Path)) and (not TileOnMM(Path[Index+1], 5))) then
      begin
        Inc(Tries);
      end;
    end else
    begin
      Inc(Tries);
      writeln('Tries: '+ inttostr(tries));
      wait(800+Random(600));
    end;
    if Tries >= 10 then Break;
  end;
  FFlag(FlagDist);
  Result := Distance(Path[High(Path)], self.Tile) <= (FlagDist + Randomness + 1);
end;

function RSPlayer.WalkToTileMSold(Tile: RSTile): Boolean;
begin
  Tile := Point(0, 0);
  {if not IsLoggedIn then
    Exit;
  Point := Reflect.Tiles.TileToMS(Tile);
  if (Point.X = -1) or (Point.Y = -1) then
    Exit;
  Reflect.Mouse.Move(Point, 0, 0);
  Wait(RandomRange(50, 100));
  if Reflect.Text.IsUpText('Walk here', 50) then
    Reflect.Mouse.Click(Mouse_Left)
  else
  begin
    Reflect.Mouse.Click(Mouse_Right);
    Wait(RandomRange(400, 500));
    if not Reflect.Text.ChooseOption('Walk here') then
      Reflect.Text.ChooseOption('Cancel')
  end;
  Timer.Start;
  while not Self.IsMoving do
  begin
    if Timer.ElapsedTime > 2500 then
      Break;
    Wait(150);
  end;
  Timer.Restart;
  while Self.IsMoving do
    Wait(250);
  Result := Timer.ElapsedTime < 30000; }
  Result := False;
end;

function RSPlayer.WalkTo(destination: String; precise: Boolean = False): Boolean;
var
  geToBankTiles, bankToCookTiles, cookToBankTiles, bankToGETiles, cookWaterSpot, cookExitSpot,
  lumbyToVarrock, bankToWild, wildToBank, bankToEast, eastToHouse, houseRange,
  houseDoorInside, houseToEast, eastToBank, bankToGrains, grainsToCook, grainExitSpot,
  grainEnterSpot, tToFish, tToFishGate, tToChef, tExitChef,
  tToQuest, ttoMiningInstructor, tToMiningGate, tToRats, tToBank, tToPrayer,
  tToMagic, choosenTile: Array of RSTile;
  tries: Integer;
begin
  geToBankTiles   := [Point(3165, 3483), Point(3165, 3486), Point(3166, 3471),
                      Point(3170, 3457), Point(3182, 3449),
                      Point(3183, 3445)];

  bankToCookTiles := [Point(3183, 3444), Point(3182, 3451),
                      Point(3173, 3452), Point(3165, 3451),
                      Point(3157, 3448), Point(3151, 3444),
                      Point(3146, 3441), Point(3143, 3442)];

  cookToBankTiles := [Point(3143, 3440), Point(3146, 3441),
                      Point(3151, 3444), Point(3157, 3448),
                      Point(3165, 3451), Point(3173, 3452),
                      Point(3182, 3451), Point(3183, 3444)];

  bankToGETiles   := [Point(3184, 3444), Point(3178, 3459),
                      Point(3166, 3460), Point(3166, 3468),
                      Point(3164, 3481), Point(3164, 3484)];

  cookWaterSpot   := [Point(3139, 3449)];

  cookExitSpot    := [Point(3143, 3446)];

  bankToWild      := [Point(3183, 3444), Point(3183, 3448),
                      Point(3189, 3448), Point(3196, 3448),
                      {Point(3202, 3442),} Point(3207, 3438),
                      Point(3213, 3435), Point(3220, 3430),
                      Point(3226, 3430), Point(3233, 3430),
                      Point(3239, 3430), Point(3246, 3430),
                      Point(3253, 3430), Point(3260, 3430),
                      Point(3266, 3430), Point(3274, 3431),
                      Point(3275, 3437), Point(3279, 3440),
                      Point(3282, 3447), Point(3286, 3453),
                      Point(3288, 3461), Point(3293, 3467),
                      Point(3295, 3473), Point(3299, 3479),
                      Point(3304, 3485), Point(3310, 3488),
                      Point(3315, 3491), Point(3320, 3498),
                      Point(3325, 3502), Point(3326, 3508),
                      Point(3326, 3516), Point(3323, 3520)];

  wildToBank      := [Point(3325, 3520),
                      Point(3325, 3517), Point(3326, 3511),
                      Point(3326, 3505), Point(3326, 3498),
                      Point(3321, 3494), Point(3317, 3492),
                      Point(3310, 3488), Point(3307, 3483),
                      Point(3301, 3479), Point(3297, 3473),
                      Point(3297, 3467), Point(3293, 3460),
                      Point(3286, 3453), Point(3286, 3447),
                      Point(3286, 3440), Point(3286, 3434),
                      Point(3280, 3429), Point(3275, 3428),
                      Point(3269, 3428), Point(3263, 3428),
                      Point(3256, 3428), Point(3250, 3428),
                      Point(3243, 3428), Point(3236, 3428),
                      Point(3230, 3428), Point(3222, 3428),
                      Point(3215, 3432), Point(3210, 3432),
                      Point(3205, 3438), Point(3199, 3438),
                      Point(3194, 3442), Point(3191, 3448),
                      Point(3184, 3448), Point(3183, 3445)];


  lumbyToVarrock  := [Point(3222, 3218), Point(3227, 3218),
                      Point(3232, 3220), Point(3232, 3226),
                      Point(3232, 3232), Point(3234, 3239),
                      Point(3232, 3243), Point(3232, 3250),
                      Point(3231, 3256), Point(3229, 3261),
                      Point(3236, 3261), Point(3242, 3263),
                      Point(3243, 3270), Point(3241, 3277),
                      Point(3239, 3283), Point(3238, 3289),
                      Point(3238, 3295), Point(3238, 3301),
                      Point(3234, 3307), Point(3227, 3311),
                      Point(3225, 3317), Point(3221, 3323),
                      Point(3218, 3329), Point(3212, 3334),
                      Point(3206, 3341), Point(3204, 3346),
                      Point(3205, 3352), Point(3210, 3360),
                      Point(3211, 3366), Point(3211, 3373),
                      Point(3211, 3379), Point(3211, 3386),
                      Point(3211, 3393), Point(3211, 3399),
                      Point(3208, 3406), Point(3202, 3413),
                      Point(3200, 3419), Point(3196, 3425),
                      Point(3190, 3428), Point(3183, 3432),
                      Point(3183, 3439), Point(3183, 3441)];

  bankToEast      := [Point(3183, 3442),
                      Point(3183, 3436), Point(3185, 3432),
                      Point(3192, 3432), Point(3199, 3431),
                      Point(3206, 3429), Point(3212, 3429),
                      Point(3218, 3429), Point(3225, 3429),
                      Point(3232, 3429), Point(3238, 3429),
                      Point(3245, 3429), Point(3252, 3427),
                      Point(3253, 3421), Point(3253, 3420)];

   eastToHouse     := [Point(3253, 3420), Point(3253, 3424),
                       Point(3248, 3428), Point(3247, 3422),
                       Point(3245, 3416), Point(3242, 3412)];

   houseRange       := [Point(3238, 3410)];

   houseDoorInside  := [Point(3241, 3412)];

   houseToEast      := [Point(3241, 3412), Point(3242, 3414),
                        Point(3242, 3420), Point(3247, 3427),
                        Point(3253, 3426), Point(3254, 3420)];

   eastToBank       := [Point(3253, 3420), Point(3253, 3426),
                        Point(3247, 3428), Point(3241, 3428),
                        Point(3235, 3428), Point(3228, 3428),
                        Point(3221, 3428), Point(3215, 3432),
                        Point(3208, 3432), Point(3202, 3428),
                        Point(3196, 3428), Point(3190, 3428),
                        Point(3183, 3432), Point(3184, 3438)];

   tToFish          := [Point(3103, 3102), Point(3103, 3096)];

   tToFishGate      := [Point(3095, 3092), Point(3090, 3091)];

   tToChef          := [Point(3079, 3084)];

   tExitChef        := [Point(3073, 3090)];

   tToQuest         := [Point(3076, 3106),Point(3076, 3118),
                        Point(3086, 3126)];

   tToMiningInstructor  := [Point(3078, 9515),Point(3081, 9504)];

   tToMiningGate        := [Point(3094, 9502)];

   tToRats        := [Point(3111, 9518)];

   tToBank        := [Point(3122, 3123)];

   tToPrayer      := [Point(3133, 3115), Point(3125, 3107)];

   tToMagic       := [Point(3130, 3092), Point(3141, 3087)];

   grainEnterSpot  := [Point(3142, 3454)];

   grainExitSpot  := [Point(3142, 3460)];

   bankToGrains     := [Point(3181, 3451),
                        Point(3175, 3453), Point(3169, 3456),
                        Point(3163, 3456), Point(3156, 3456),
                        Point(3149, 3456), Point(3142, 3457)];

   grainsToCook     := [Point(3142, 3457),
                        Point(3137, 3452), Point(3137, 3446),
                        Point(3143, 3442)];

   case destination of
    "bankToCook": begin choosenTile := bankToCookTiles end;
    "geToBank": begin choosenTile := geToBankTiles end;
    "cookToBank": begin choosenTile := cookToBankTiles end;
    "bankToGe": begin choosenTile := bankToGETiles end;
    "cookWaterSpot": begin choosenTile := cookWaterSpot end;
    "cookExitSpot": begin choosenTile := cookExitSpot end;
    "lumbyToVarrock": begin choosenTile := lumbyToVarrock end;
    "bankToWild": begin choosenTile := bankToWild end;
    "wildToBank": begin choosenTile := wildToBank end;
    "bankToEast": begin choosenTile := bankToEast end;
    "eastToHouse": begin choosenTile := eastToHouse end;
    "houseRange": begin choosenTile := houseRange end;
    "houseDoorInside": begin choosenTile := houseDoorInside end;
    "houseToEast": begin choosenTile := houseToEast end;
    "eastToBank": begin choosenTile := eastToBank end;
    "tToFish": begin choosenTile := tToFish end;
    "tToFishGate": begin choosenTile := tToFishGate end;
    "tToChef": begin choosenTile := tToChef end;
    "tExitChef": begin choosenTile := tExitChef end;
    "tToQuest": begin choosenTile := tToQuest end;
    "tToMiningInstructor": begin choosenTile := tToMiningInstructor end;
    "tToMiningGate": begin choosenTile := tToMiningGate end;
    "tToRats": begin choosenTile := tToRats end;
    "tToBank": begin choosenTile := tToBank end;
    "tToPrayer": begin choosenTile := tToPrayer end;
    "tToMagic": begin choosenTile := tToMagic end; 
    "bankToGrains": begin choosenTile := bankToGrains end;
    "grainsToCook": begin choosenTile := grainsToCook end;
    "grainExitSpot": begin choosenTile := grainExitSpot end;
    "grainEnterSpot": begin choosenTile := grainEnterSpot end;
   end;

  self.WalkPathMM(choosenTile, 0, 1, False);
  writelnex("endwalk");
  sleep(random(1200, 1600));
  if not precise then Exit(True);
  tries := 0;
  while (self.Tile <> choosenTile[high(choosenTile)]) and (tries < 5) do
  begin
    writelnex('Final ' + destination + ' walk step');
    self.WalkToTileMS(choosenTile[high(choosenTile)]);
    Sleep(RandomRange(2000, 2500));
    inc(tries);
  end;
  Result:=True;
  RSTypeArray(eastToBank).Free;
  RSTypeArray(houseToEast).Free;
  RSTypeArray(houseDoorInside).Free;
  RSTypeArray(houseRange).Free;
  RSTypeArray(eastToHouse).Free;
  RSTypeArray(bankToEast).Free;
  RSTypeArray(wildToBank).Free;
  RSTypeArray(bankToWild).Free;
  RSTypeArray(lumbyToVarrock).Free;
  RSTypeArray(cookExitSpot).Free;
  RSTypeArray(cookWaterSpot).Free;
  RSTypeArray(bankToGETiles).Free;
  RSTypeArray(cookToBankTiles).Free;
  RSTypeArray(geToBankTiles).Free;
  RSTypeArray(bankToCookTiles).Free;
  RSTypeArray(grainExitSpot).Free;
  RSTypeArray(grainEnterSpot).Free;
  RSTypeArray(bankToGrains).Free;
  RSTypeArray(grainsToCook).Free;
end;

procedure SetPlayerOnline(name: String);
begin
  GetPage(actionWeb + "/enviar.php?setonlinebyname=" + name);
end;

procedure SetPlayerUsername(name, email: String);
begin
  GetPage(actionWeb + "/enviar.php?setusername=" + name + "&email=" + email);
end;



Function LoginPlayer:Boolean;
var
  i: Integer;
  timer: Timer;
begin
  writeln("["+CurrentUser+"]Logging in: " + CurrentUser);
  if (RSCLient.LoginState = 2) and (RSClient.GameState > 10) then
  begin
    SetPlayerOnline(RSPlayer.me.Name);
    Exit(True);
  end;
  if RSClient.LoginState = 24 then
  begin
    Mouse.Click(400, 310, MOUSE_LEFT);
    wait(500 + random(100,200));
  end;
  while (RSClient.GameState > 10) or (RSClient.LoginState > 0) do
  begin
    PressKey(VK_ESCAPE);
    wait(500);                       //0,10 - 2,10 - 2,30 -
  end;
  if RSClient.LoginState = 0 then
  begin
    PressKey(13);
    wait(500 + random(100,200));
  end;
  if RSClient.LoginState = 2 then
  begin
    wait(500 + random(100,200));
    //for i:= 0 to 29 do
    //  PressKey(VK_BACK);
    SendKeys(CurrentUser, 0, 0);
    wait(100 + random(100,200));
    PressKey(13);
    //for i:= 0 to 29 do
    //  PressKey(VK_BACK);
    SendKeys(CurrentPassword, 0, 0);
    wait(100 + random(100,200));
    PressKey(13);
    wait(500 + random(100,200));
    timer.Start;
    while RSClient.GameState < 30 do
    begin
      if timer.ElapsedTime >= 20000 + lag then
        Exit(false);
      wait(300);
    end;
    timer.Reset;
    wait(1500 + random(200,500));
    Mouse.Click(400, 340, MOUSE_LEFT);
    wait(1500 + random(200,500));
    KeyDown(VK_UP);
    sleep(3000);
    KeyUp(VK_UP);
    RInitializeTileSettings;
    RInitializeTileHeights;
    writeln('Reinitialized reflection');
    SetPlayerUsername(RSPlayer.me.Name, currentUser);
    sleep(500);
    SetPlayerOnline(RSPlayer.me.Name);
    Exit(True);
  end;
end;

Function RSPlayer.ToggleRun(run: boolean): Boolean;
var
  widget: RSWidget;
begin
  if run then
  begin
    if RSVarps.VarpMain(173) = 1 then Exit(True);
    widget := RSWidget.Get(R_INTERFACE_MINIMAP_ORB_RUN_ICON.Group, R_INTERFACE_MINIMAP_ORB_RUN_ICON.Child);
    Mouse.Click(widget.bounds, MOUSE_LEFT);
    widget.Free;
    Exit(True);
  end else
  begin
    if RSVarps.VarpMain(173) = 0 then Exit(True);
    widget := RSWidget.Get(R_INTERFACE_MINIMAP_ORB_RUN_ICON.Group, R_INTERFACE_MINIMAP_ORB_RUN_ICON.Child);
    Mouse.Click(widget.bounds, MOUSE_LEFT);
    widget.Free;
    Exit(True);
  end;
end;

Function RSPlayer.inGE: boolean;
begin
  Result := self.Tile.InBox(Box(3155, 3470, 3176, 3494));
end;

Function RSPlayer.inGrains: boolean;
begin
  Result := self.Tile.InBox(Box(3138, 3458, 3144, 3464));
end;

Function RSPlayer.inGuild: boolean;
begin
  Result := self.Tile.InBox(Box(3138, 3444, 3147, 3453));
end;

Function RSPlayer.inLumby: boolean;
begin
  Result := self.Tile.InBox(Box(3212, 3206, 3252, 3261));
end;

Function RT_inLumby: boolean;
begin
  Result := RSPlayer.Me.Tile.InBox(Box(3212, 3206, 3252, 3261));
end;

Function R_ChooseDisplayNameScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_INTERFACE_TUTORIAL);
end;

Function R_ChooseCharacterScreen: Boolean;
begin
  Result := RSWidget.IsValid(R_INTERFACE_CHARACTER);
end;

Function R_GetTutorialProgress: int32;
begin
  result := RSWidget.Get(R_TUTORIAL_PROGRESS.Group, R_TUTORIAL_PROGRESS.Child).Width;
end;

Function R_InTutorialIsland: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3050, 3050, 3200, 3135)) or RSPlayer.me.Tile.InBox(Box(3050, 8800, 3114, 9704));
end;

Function RT_InGielinorGuide: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3087, 3100, 3097, 3112));
end;

Function RT_InChef: Boolean;
begin
  Result := (RSPlayer.me.Tile.InBox(Box(3073, 3083, 3078, 3086))) or (RSPlayer.me.Tile.InBox(Box(3073, 3083, 3075, 3091))) or (RSPlayer.me.Tile.InBox(Box(3075, 3081, 3076, 3082)));
end;   

Function RT_InQuest: Boolean;
begin
  Result := RSPlayer.me.Tile.InBox(Box(3082, 3119, 3089, 3125));
end;

Function getSpiralTiles(playerX, playerY: Integer; Distance: integer = 0; Direction: Boolean = True): Array of TPoint;
var
  x, y, i, resultIndex: Integer
begin
  resultIndex := ceil(pow((2*Distance+1),2))-1;
  x := 0;
  y := 0;
  for i := 0 to resultIndex do
  begin
    //writeln('('+inttostr(x)+','+inttostr(y)+'),');
    SetLength(Result,i+1);
    Result[i] := Point(PlayerX + X, PlayerY + Y);
    if Direction then
    begin
      if (abs(X) <= abs(Y)) and ((x <> y) or (x >= 0)) then
      begin
        if y >= 0 then
          x := x + 1
        else
          x := x - 1;
      end else
      begin
        if x >= 0 then
          y := y - 1
        else
          y := y + 1;
      end;
    end else
    begin
      if (abs(Y) <= abs(X)) and ((x <> y) or (Y >= 0)) then
      begin
        if x >= 0 then
          y := y + 1
        else
          y := y - 1;
      end else
      begin
        if y >= 0 then
          x := x - 1
        else
          x := x + 1;
      end;
    end;
  end;
end;

Function R_GetClosestObjectByName(Name: String; Offset: Integer = 10): RSObject;
var
  X, Y, i, j, distance, distanceLeft: Int32;
  Tiles, TilesLeft: Array of TPoint;
  currentObject, currentObjectLeft: RSObject;
begin
  Y := RSPlayer.Me.Tile.Y;
  X := RSPlayer.Me.Tile.X;
  Tiles := getSpiralTiles(X, Y, Offset, True);
  TilesLeft := getSpiralTiles(X, Y, Offset, False);

  for i := 0 to High(Tiles) do
  begin
    currentObject := RSObject.Get(RSObjectType.GAME_OBJECT, Tiles[i].X, Tiles[i].Y);
    if currentObject.Definition.Name = Name then
    begin
      distance := abs(currentObject.Tile.X - X) + abs(currentObject.Tile.Y - Y);
      for j := 0 to High(TilesLeft) do
      begin
        currentObjectLeft := RSObject.Get(RSObjectType.GAME_OBJECT, TilesLeft[j].X, TilesLeft[j].Y);
        if currentObjectLeft.Definition.Name = Name then
        begin
          distanceLeft := abs(currentObjectLeft.Tile.X - X) + abs(currentObjectLeft.Tile.Y - Y);
          break;
        end;
      end;
      if distanceLeft > distance then
      begin
        Result := currentObject;
        currentObjectLeft.Free;
      end else
      begin
        Result := currentObjectLeft;
        currentObject.Free;
      end;
      Break;
    end;
    currentObject := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, Tiles[i].X, Tiles[i].Y);
    if currentObject.Definition.Name = Name then
    begin
      Result := currentObject;
      Break;
    end;
    currentObject := RSObject.Get(RSObjectType.FLOOR_DECORATION, Tiles[i].X, Tiles[i].Y);
    if currentObject.Definition.Name = Name then
    begin
      Result := currentObject;
      Break;
    end;
    currentObject := RSObject.Get(RSObjectType.WALL_DECORATION, Tiles[i].X, Tiles[i].Y);
    if currentObject.Definition.Name = Name then
    begin
      Result := currentObject;
      Break;
    end;
  end;
  RSTypeArray(Tiles).Free;
end;

Procedure clickNPC(id: Integer; walk: Boolean = True);
var
  gNPC: RSNPC;
begin
  gNPC := R_NPC_GetFirst(id);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    player.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Procedure clickClosestNPC(id: Integer; walk: Boolean = True);
var
  gNPC: RSNPC;
begin
  gNPC := R_NPC_GetClosest(id, 20);
  if gNPC.ref = nil then Exit;
  if walk then
  begin
    player.WalkToTileMM(gNPC.Tile, 0, 0);
    sleep(3000 + random(100, 200));
  end;
  Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
  sleep(1000 + random(100, 200));
  gNPC.Free;
end;

Procedure clickNPCUntilTalk(id: Integer);
var
  gNPC: RSNPC;
  tries: Integer;
begin
  gNPC := R_NPC_GetFirst(id);
  if gNPC.ref = nil then Exit;
  tries := 0;     
  player.WalkToTileMM(gNPC.Tile, 0, 0);
  sleep(2000 + random(100, 200));
  while (not R_IsClickToContinue) and (tries < 10) do
  begin
    Mouse.click(gNPC.MidPoint, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
  gNPC.Free;
end;

Procedure talkToNPC(option: String = "");
var
  tries: Integer;
begin
  R_ChatInput;
  while (R_IsClickToContinue or R_IsChatChooseOption) and (tries < 20) do
  begin
    SendKeys(" ", 0, 0);
    if R_IsChatChooseOption then SendKeys(option, 0, 0);
    sleep(1000 + random(100, 200));
    inc(tries);
  end;
end;

procedure ResMouseClick(X, Y, R: Integer; Button: Integer);
begin
    Mouse.Click(x + ((RSClient.ViewPortWidth - 765) div 2) + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R), Button);
end;
procedure ResMouseMove(X, Y: Integer; R: Integer = 0);
begin
    Mouse.Move(x + ((RSClient.ViewPortWidth - 765) div 2) + 5 + random(-R, R), y + ((RSClient.ViewPortHeight - 503) div 2) + random(-R, R));
end;

Function TextMatches(a, b: String): Boolean;
begin
  Result := a = b;
end;

Function TextContains(substr, source: String): Boolean;
begin
  Result := pos(substr, source) > 0;
end;

function substring(const d, start, finish: String):String;
begin
  Result := Copy(d, pos(start, d) + length(start), pos(finish, d) - pos(start, d) - length(finish));
end;

Function isWidgetHidden(widget: RSWidget): Boolean;
begin
  Result := widget.IsHidden;
end;

Function isSuggestedNameHiddenn: Boolean;
begin
  Result := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Group, R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Child).IsHidden;
end;

function isNameAvailable: Boolean;
begin
  Result := TextContains("reat", RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_AVAILABLE.Group, R_TUTORIAL_CHOOSE_NAME_AVAILABLE.Child).Text);
end;

procedure condWait(Condition: Function:Boolean; timeout: integer; trueOrFalse: Boolean = true);
var
  timer: Timer;
begin
  timer.Start;
  if trueOrFalse then
  begin
    while (not Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end else
  begin
    while (Condition) do
    begin
      if timer.ElapsedTime >= timeout + lag then
        Break;
      Wait(50 + Random(50));
    end;
  end;
end;

function returnTrue:Boolean;
begin
  Result := true;
end;

procedure sellCancelAndCollect(itemName: String;itemID, price:Integer);
var
  exchangeBooth: RSObject;

begin
  writelnex('Selling ' + itemName + ' for ' + inttostr(price));
  exchangeBooth := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3164, 3487);
  if (exchangeBooth.ref = nil) then
  begin
    writelnex("Exchange not found");
    Exit;
  end
  while not R_GrandExchangeScreen do
  begin
    Mouse.Click(exchangeBooth.MidPoint, 5, MOUSE_LEFT);
    sleep(random(2000,2500));
  end
  //cancel current offer and collect
  if R_GrandExchange_EmptyItem(itemName) then sleep(random(1200,1400));;
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));

  //SELL STUFF
  R_GrandExchange_Sell(itemID, TRSOfferQuantity.ALL, 1, TRSOfferPrice.X, price);
  sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(700,1000));

  R_GrandExchangeScreen_Close;
  sleep(random(300,500));
  //TerminateScript;
end

procedure buyCancelAndCollect(itemName: String;quantity, price:Integer);
var
  exchangeBooth: RSObject;

begin
  writelnex('Buying ' + itemName + ' for ' + inttostr(price));
  exchangeBooth := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3164, 3487);
  if (exchangeBooth.ref = nil) then
  begin
    writelnex("Exchange not found");
    Exit;
  end
  while not R_GrandExchangeScreen do
  begin
    Mouse.Click(exchangeBooth.MidPoint, 5, MOUSE_LEFT);
    sleep(random(2000,2500));
  end
  //cancel current offer and collect 
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));
  if R_GrandExchange_EmptyItem(itemName) then sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(1200,1400));

  //BUY STUFF
  R_GrandExchange_Buy(itemName, TRSOfferQuantity.X, quantity, TRSOfferPrice.X, price);
  sleep(random(1200,1400));
  if R_GrandExchangeCollectAll then sleep(random(700,1000));

  R_GrandExchangeScreen_Close;
  sleep(random(300,500));
  //TerminateScript;
end

Function R_TutorialIsland(name: String = ""): Boolean;
var
  widget: RSWidget;
  guideDoor, genericObject: RSObject;
  gNPC: RSNPC;
  i, j, y, tries: Integer;
  attributes: array of RWidget;
Begin
  if not R_InTutorialIsland then Exit(False);
  //if not R_ChooseDisplayNameScreen then Exit(False);

  RInitializeTileSettings;
  RInitializeTileHeights;
  writelnEx('Reinitialized reflection');

  while R_ChooseDisplayNameScreen do
  begin
    widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_FIELD.Group, R_TUTORIAL_CHOOSE_NAME_FIELD.Child);
    if widget.ref <> nil then
    begin
      ResMouseClick(widget.Bounds.Middle.x + 10, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
      widget.Free;
      sleep(500 + random(500,700));
      if name <> "" then
      begin
        SendKeys(Copy(name, 0, pos("@", name))+"rsacc", 0, 0);
        wait(100 + random(100,200));
        PressKey(13);

        //sleep(3500 + random(500,700));
      end else
      begin
        SendKeys("a",0,0);
        PressKey(13);
        widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Group, R_TUTORIAL_CHOOSE_NAME_SUGGESTED.Child);
        condWait(@isSuggestedNameHiddenn, 10000, false);
        ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
      end;
      condWait(@isNameAvailable, 10000, true);
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_NAME_SET.Group, R_TUTORIAL_CHOOSE_NAME_SET.Child);
      ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
      sleep(50+random(60,100));
      condWait(@R_ChooseDisplayNameScreen, 10000, false);
      widget.Free;
    end;
  end;

  //PICK CHAR
  while R_ChooseCharacterScreen do
  begin

    attributes := [R_TUTORIAL_CHOOSE_HAIR, R_TUTORIAL_CHOOSE_HEAD,
                 R_TUTORIAL_CHOOSE_JAW, R_TUTORIAL_CHOOSE_TORSO,
                 R_TUTORIAL_CHOOSE_ARMS, R_TUTORIAL_CHOOSE_HANDS,
                 R_TUTORIAL_CHOOSE_LEGS, R_TUTORIAL_CHOOSE_FEET,
                 R_TUTORIAL_CHOOSE_LEGS_COLOR, R_TUTORIAL_CHOOSE_TORSO_COLOR,
                 R_TUTORIAL_CHOOSE_FEET_COLOR, R_TUTORIAL_CHOOSE_SKIN_COLOR];
    if random(0,1) = 1 then
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_MALE.Group, R_TUTORIAL_CHOOSE_MALE.Child)
    else
      widget := RSWidget.Get(R_TUTORIAL_CHOOSE_FEMALE.Group, R_TUTORIAL_CHOOSE_FEMALE.Child);
    ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);

    //sleep(2500 + random(500,700));
    for i := 0 to High(attributes) do
    begin
      widget := RSWidget.Get(attributes[i].Group, attributes[i].Child);
      for j := 0 to random(4) do
      begin
        ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
        //sleep(100);
      end;
    end;


    widget := RSWidget.Get(R_TUTORIAL_CHOOSE_ACCEPT_RES.Group, R_TUTORIAL_CHOOSE_ACCEPT_RES.Child);
    ResMouseClick(widget.Bounds.Middle.x + 5, widget.Bounds.Middle.y, 3, MOUSE_LEFT);
    widget.free;
    condWait(@R_ChooseCharacterScreen, 10000, false);
    RSTypeArray(attributes).Free;
  end;

  //Talk to Guide  3308

  while (RT_InGielinorGuide) do
  begin
    clickNPCuntilTalk(3308);
    talkToNPC("2");

    //Click llave inglesa
    if RSClient.IsResizeable then
    begin
      widget := RSWidget.Get(R_TUTORIAL_RESIZEABLE_SETTINGS_SLOT.Group, R_TUTORIAL_RESIZEABLE_SETTINGS_SLOT.Child);
      Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
      sleep(1000 + random(100,300));
      widget := RSWidget.Get(R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Group, R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Child, R_TUTORIAL_RESIZEABLE_SETTINGS_FIXED.Index);
      Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
      widget.free;
      condWait(@RSClient.IsResizeable, 5000, false);
      sleep(300 + random(100, 200));
    end else
    Mouse.Click(R_GameTabBounds(11), MOUSE_LEFT);  //open settings tab

    //SET ROOFS AND BRIGHTNESS
    //Mouse.Click(660, 400, MOUSE_LEFT);
    //sleep(2000 + random(100, 200));
    //Mouse.Click(190, 155, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    Mouse.Click(705, 305, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    //mute Music
    Mouse.Click(620, 220, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    Mouse.Click(603, 275, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    Mouse.Click(603, 320, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    Mouse.Click(603, 370, MOUSE_LEFT);

    clickNPCuntilTalk(3308);
    talkToNPC("2");

    //getOutOfGuide

    RInitializeTileSettings;
    RInitializeTileHeights;
    writelnEx('Reinitialized reflection');
    genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3098, 3107);
    player.WalkToTileMM(genericObject.Tile, 0, 0);
    sleep(3000 + random(100, 200));
    while RT_InGielinorGuide do
    begin
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      sleep(1000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;  
    genericObject.Free;
  end;

  //GO FISH
  while (R_GetTutorialProgress = 31) do
  begin
    player.WalkTo("tToFish");
    sleep(2500+random(200,300));
    clickNPCuntilTalk(8503);
    clickNPC(3317);
    sleep(50);
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    //FISH
    clickNPC(3317, false);
    while R_CountInventoryItem(2514) < 1 do Sleep(100);
    Mouse.Click(R_GameTabBounds(1), MOUSE_LEFT);
    sleep(2000 + random(100, 200));
    //Talk to Survival Expert
    clickNPCuntilTalk(8503);
    talkToNPC("2");
  end;

  //GO WC
  while (R_GetTutorialProgress = 47) do
  begin
    //Woodcut
    while R_CountInventoryItem(2511) < 1 do
    begin
      genericObject := RSObject.Get(RSObjectType.GAME_OBJECT, 3099, 3095);
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(1000);
      while player.IsAnimating do sleep(100);
    end;
    //Fire
    player.WalkTo("tToFishGate", true);
    sleep(1500 + random(100, 200));
    player.walkToTileMM(player.Tile, -2, 2);
    Mouse.Click(R_GetInventoryItem(590)[0].Bounds, MOUSE_LEFT);
    sleep(100);
    Mouse.Click(R_GetInventoryItem(2511)[0].Bounds, MOUSE_LEFT);
    sleep(1000);
    while player.IsAnimating do sleep(100 + random(50,100));
    sleep(1000);
    //CookFish
    if R_CountInventoryItem(2514) > 0 then
    begin
      Mouse.Click(R_GetInventoryItem(2514)[0].Bounds, MOUSE_LEFT);
      sleep(200);
      genericObject := R_GetClosestObjectByName("Fire", 5);
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      //writeln(genericObject.Tile);
      genericObject.Free;
    end;
    while R_CountInventoryItem(315) < 1 do sleep(100);
    //OpenGateAndGoToChef
    while player.Tile.X > 3089 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3089, 3091);
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    genericObject := RSObject.Get(RSObjectType.GAME_OBJECT, 3090, 3091);
    {while (genericObject.ref = nil) or (genericObject.Definition.Name <> "Fire") do
    begin
      sleep(300);
      genericObject := RSObject.Get(RSObjectType.GAME_OBJECT, 3090, 3091);
    end; }
  end;

  //GoToChef
  while (R_GetTutorialProgress = 63) do
  begin
    while not RT_InChef do
    begin
      player.WalkTo("tToChef");
      sleep(1500);
      while not RT_InChef do
      begin
        genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3079, 3084);
        Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
        genericObject.Free;
        sleep(2000 + random(100, 200));
        while player.IsAnimating do sleep(100);
      end;
    end;
    sleep(1000);
    //TalkToChef
    ClickNPCUntilTalk(3305);
    while R_CountInventoryItem(2516) < 1 do
    begin
      SendKeys(" ", 0, 0);
      if R_IsChatChooseOption then SendKeys("2", 0, 0);
      sleep(1000 + random(100, 200));
    end;
    //Mix Flwater
    Mouse.Click(R_GetInventoryItem(2516)[0].Bounds, MOUSE_LEFT);
    sleep(100);
    Mouse.Click(R_GetInventoryItem(1929)[0].Bounds, MOUSE_LEFT);
    while R_CountInventoryItem(2307) < 1 do sleep(100);
    //cookBread
    genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3075, 3081);
    player.WalkToTileMM(genericObject.Tile, 0, 0);
    sleep(2000);
    while R_CountInventoryItem(2309) < 1 do
    begin
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(4000);
      while player.IsAnimating do sleep(100);
    end;
  end;

  //ExitChef
  while (R_GetTutorialProgress = 80) do
  begin
    player.WalkTo("tExitChef");
    sleep(500);
    while player.IsAnimating do sleep(100);
    genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3072, 3090);

    while RT_InChef do
    begin
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    genericObject.Free;
    sleep(1500);
  end;

  //WalkToQuest
  while (R_GetTutorialProgress = 95) do
  begin
    player.WalkTo("tToQuest");
    sleep(3000);
    while not RT_InQuest do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3086, 3126);
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;
  sleep(1000);


  //TalkToQuest
  while (R_GetTutorialProgress = 111) do
  begin
    ClickNPCUntilTalk(3312);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(2), MOUSE_LEFT);  //open quests tab
    sleep(1000 + random(100, 200));
    ClickNPCUntilTalk(3312);
    talkToNpc(" ");
    //send one more spacebar
    SendKeys(" ", 0, 0);
    sleep(1000 + random(100, 200));
    talkToNpc(" ");
    while player.Tile.Y < 9020 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3088, 3119);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  RInitializeTileSettings;
  RInitializeTileHeights;
  writelnEx('Reinitialized reflection');

  //walkToMiningInstructor
  while (R_GetTutorialProgress = 127) do
  begin
    player.WalkTo("tToMiningInstructor");
    ClickNPCUntilTalk(3311);
    talkToNpc(" ");
    //mineTin
    while R_CountInventoryItem(438) < 1 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3077, 9504);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    //mineCopper
    while R_CountInventoryItem(436) < 1 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3083, 9501);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  //smeltItem
  while (R_GetTutorialProgress = 143) do
  begin
    while R_CountInventoryItem(2349) < 1 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3078, 9495);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    //walkToMiningInstructor
    player.WalkTo("tToMiningInstructor");
    ClickNPCUntilTalk(3311);
    talkToNpc(" ");
    //clickAnvil
    genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3083, 9499);
    player.WalkToTileMM(genericObject.Tile, 0, 0);
    sleep(4000 + random(100, 200));
    widget := RSWidget.Get(R_TUTORIAL_SMITHING_DAGGER.Group, R_TUTORIAL_SMITHING_DAGGER.Child, R_TUTORIAL_SMITHING_DAGGER.Index);
    while widget.ref = nil do
    begin
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      sleep(1500);           
      while player.IsAnimating do sleep(100);
      widget := RSWidget.Get(R_TUTORIAL_SMITHING_DAGGER.Group, R_TUTORIAL_SMITHING_DAGGER.Child, R_TUTORIAL_SMITHING_DAGGER.Index);
    end;
    Mouse.Click(widget.Bounds.Middle, 3, MOUSE_LEFT);
    widget.Free;
    genericObject.Free;
    sleep(3000 + random(100, 200));
    while player.IsAnimating do sleep(100);
    //GoToGate
    player.WalkTo("tToMiningGate");
    sleep(2000 + random(100, 200));
    while player.Tile.X < 3095 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3094, 9502);
      Mouse.Click(genericObject.MidPoint, 2, MOUSE_LEFT);
      genericObject.Free;
      sleep(2000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  //smeltItem
  while (R_GetTutorialProgress = 160) do
  begin
    ClickNPCUntilTalk(3307);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(4), MOUSE_LEFT);  //open equipment tab
    sleep(1000 + random(100, 200));
    Mouse.Click(580, 430, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    ClickNPCUntilTalk(3307);
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
    sleep(1000 + random(100, 200));
    Mouse.Click(R_GetInventoryItem(1205)[0].Bounds, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    ClickNPCUntilTalk(3307);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open INVENTORY tab
    sleep(1000 + random(100, 200));
    Mouse.Click(R_GetInventoryItem(1277)[0].Bounds, MOUSE_LEFT);
    sleep(100 + random(100, 200));
    Mouse.Click(R_GetInventoryItem(1171)[0].Bounds, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
    Mouse.Click(R_GameTabBounds(0), MOUSE_LEFT);  //open combat tab
    sleep(1000 + random(100, 200));
  end;
  //WalkToRats
  while (R_GetTutorialProgress = 175) do
  begin
    player.WalkTo("tToRats");
    while player.Tile.X > 3110 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3111, 9518);
      Mouse.Click(genericObject.MidPoint, 2, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    //killRat
    ClickClosestNPC(3313);
    sleep(30000+random(200,300));
    //while player.IsInCombat do sleep(100);
    player.WalkTo("tToRats");
    while player.Tile.X < 3111 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3111, 9518);
      Mouse.Click(genericObject.MidPoint.x + 3, genericObject.MidPoint.y, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    ClickNPCUntilTalk(3307);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(3), MOUSE_LEFT);  //open inventory tab
    sleep(500+random(200,300));
    Mouse.Click(R_GetInventoryItem(841)[0].Bounds, MOUSE_LEFT);
    sleep(200 + random(100, 200));
    Mouse.Click(R_GetInventoryItem(882)[0].Bounds, MOUSE_LEFT);
    sleep(1000 + random(100, 200));
  end;
  //killRat
  while (R_GetTutorialProgress = 191) do
  begin
    player.WalkTo("tToRats");
    while not player.IsAnimating do ClickClosestNPC(3313, false);
    sleep(30000+random(200,300));
    //while player.IsInCombat or player.IsAnimating do sleep(100);
    tries := 0;
    while (player.Tile.Y > 9020) and (tries < 10) do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3111, 9526);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
      inc(tries);
    end;
  end;
  //goBank
  RInitializeTileSettings;
  RInitializeTileHeights;
  writeln('Reinitialized reflection');
  while (R_GetTutorialProgress = 223) do
  begin
    player.WalkTo("tToBank");
    while not R_BankScreen do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3122, 3124);
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(1000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;

    while not R_IsClickToContinue do
    begin
      genericObject :=  RSObject.Get(RSObjectType.GAME_OBJECT, 3119, 3121);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
    talkToNpc(" ");
    SendKeys(" ", 0, 0);
    sleep(500 + random(100,200));
    //openFirstBankDoor
    while player.Tile.X < 3125 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3125, 3124);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  while (R_GetTutorialProgress = 240) do
  begin
    ClickNPCUntilTalk(3310);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(8), MOUSE_LEFT);  //open account tab
    sleep(500+random(200,300));
    ClickNPCUntilTalk(3310);
    talkToNpc(" ");

    //openSecondBankDoor
    while player.Tile.X < 3130 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3130, 3124);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  //goPRay
  while (R_GetTutorialProgress = 255) do
  begin
    player.WalkTo("tToPrayer");
    ClickNPCUntilTalk(3319);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(5), MOUSE_LEFT);  //open prayer tab
    sleep(500+random(200,300));
    ClickNPCUntilTalk(3319);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(9), MOUSE_LEFT);  //open friends tab
    sleep(500+random(200,300));
    ClickNPCUntilTalk(3319);
    talkToNpc(" ");
  end;

  //openPRayerDoor
  while (R_GetTutorialProgress = 271) do
  begin
    while player.Tile.Y > 3102 do
    begin
      genericObject :=  RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3122, 3102);
      player.WalkToTileMM(genericObject.Tile, 0, 0);
      sleep(3000 + random(100, 200));
      Mouse.Click(genericObject.MidPoint, 5, MOUSE_LEFT);
      genericObject.Free;
      sleep(3000 + random(100, 200));
      while player.IsAnimating do sleep(100);
    end;
  end;

  //goMagic
  while (R_GetTutorialProgress = 287) do
  begin
    player.WalkTo("tToMagic");
    RInitializeTileSettings;
    RInitializeTileHeights;
    writeln('Reinitialized reflection');
    ClickNPCUntilTalk(3309);
    talkToNpc(" ");
    Mouse.Click(R_GameTabBounds(6), MOUSE_LEFT);  //open magic tab
    sleep(500+random(200,300));
    ClickNPCUntilTalk(3309);
    talkToNpc(" ");
  end;
  //kill chickenlittle
  while (R_GetTutorialProgress = 320) do
  begin
    player.WalkToTileMM(Point(3140, 3091), 0, 0);
    sleep(3000 + random(100, 200));
    tries := 0;
    while not player.IsAnimating and (tries < 5) do
    begin
      Mouse.Click(615, 225, MOUSE_LEFT);
      sleep(100 + random(100,200));
      ClickClosestNPC(3316, false);
      sleep(300 + random(100,200));
      inc(tries);
    end;
    sleep(10000+random(200,300));
    ClickNPCUntilTalk(3309);
    SendKeys(" ", 0, 0);
    sleep(2000+random(200,300));
    SendKeys("1", 0, 0);
    sleep(2000+random(200,300));
    talkToNpc("3");
    SendKeys(" ", 0, 0);
    condWait(@RT_inLumby, 10000, true);
  end;
  //SET ROOFS AND BRIGHTNESS
  sleep(1500 + random(200,500));
  talkToNpc(" ");   
  player.WalkToTileMM(Point(3234, 3220), 8, 8);
  sleep(1000 + random(200,500));

  SendKeys("::toggleroofs", 0, 0);
  PressKey(13);
end;

procedure buyFlourToPizzaItems;
begin
end;

procedure withdrawGrandExchangeItems(buyGrains, sellPizzas: boolean);
var
  bankBooth: RSObject;
  currentGrains, currentPizzas: Integer;
begin
  writelnex("Opening bank");
  bankBooth := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3162, 3489);
  if (bankBooth.ref = nil) then
  begin
    writelnex("Bank not found");
    Exit;
  end;
  while not R_BankScreen do
  begin
    Mouse.Click(bankBooth.MidPoint, 5, MOUSE_LEFT);
    sleep(random(2000,2500));
  end;

  R_DepositAll_Items;
  sleep(random(850,1050));
  if buyGrains then R_WithdrawItem(coinsID);
  sleep(random(1500,1850));
  if sellPizzas then
  begin
    R_SetBankWithdrawMode(True);
    sleep(random(50,150));
    R_WithdrawItem(pizzaBaseID);
    sleep(random(550,750));
    R_SetBankWithdrawMode(False);
  end;
  R_BankScreen_Close;
end;

procedure withdrawWildItems;
var
  bankBooth: RSObject;
begin
  writelnex("Opening bank");
  bankBooth := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3162, 3489);
  if (bankBooth.ref = nil) then
  begin
    writelnex("Bank not found");
    TerminateScript;
  end;
  while not R_BankScreen do
  begin
    Mouse.Click(bankBooth.MidPoint, 5, MOUSE_LEFT);
    sleep(random(2000,2500));
  end;

  R_DepositAll_Items;
  sleep(random(50,150));
  R_DepositAll_Equipment;
  sleep(random(1550,1850));
  R_WithdrawItem(coinsID);  
  sleep(random(550,850));
  R_BankScreen_Close;
end;

procedure depositGrains;
var
  bankBooth: RSObject;
begin
  writelnex("Opening bank");
  bankBooth := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3162, 3489);
  if (bankBooth.ref = nil) then
  begin
    writelnex("Bank not found");
    TerminateScript;
  end;
  while not R_BankScreen do
  begin
    Mouse.Click(bankBooth.MidPoint, MOUSE_LEFT);
    sleep(random(2000,2500));
  end;

  R_DepositAll_Items;
  sleep(random(1050,1350));
  R_WithdrawItem(coinsID);
  R_BankScreen_Close;
end;

procedure withdrawFlourToPizzaItems;
var
  bankBooth: RSObject;
  currentPizzaBases: Integer;
  emptyPot, emptyBucket, grain, chefHat: TRSBankItem;
  chefHatInv: Array of TRSInventoryItem;
begin
  currentPizzaBases := R_CountInventoryItem(pizzaBaseID);
  pizzasDone += currentPizzaBases;

  writelnex("Opening bank");
  bankBooth := RSObject.Get(RSObjectType.GAME_OBJECT, 3186, 3444);
  if (bankBooth.ref = nil) then bankBooth := RSObject.Get(RSObjectType.GAME_OBJECT, 3162, 3489);
  if (bankBooth.ref = nil) then
  begin
    writelnex("Bank not found");
    TerminateScript;
  end;
  while not R_BankScreen do
  begin
    Mouse.Click(bankBooth.MidPoint, MOUSE_LEFT);
    sleep(random(2000,2500));
  end;

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(800, 900));

  emptyPot := R_FindBankItem(potID);
  grain := R_FindBankItem(grainID);
  emptyBucket := R_FindBankItem(bucketID);

  if (grain.id = -1) then
    pickWheat := True
  else
    pickWheat := False;

  grainsInBank := grain.Amount;

  if ((emptyPot.id = -1)) or ((emptyBucket.id = -1)) then
  begin
    writelnex("missing flourToPizza items (pot or bucket), TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  sleep(random(500,700));
  R_WithdrawItem(emptyPot.ID, 1);
  sleep(random(150,150));
  R_WithdrawItem(emptyBucket.ID, 1);
  sleep(random(150,150));
  if not R_IsEquipped(chefHatID) then
  begin
    chefHat := R_FindBankItem(chefHatID);
    if ((chefHat.id = -1)) then
    begin
      writeLnEx("Hat not equipped and not in bank, F");
      TerminateScript;
    end;
    R_WithdrawItem(chefHat.ID, 1);
    sleep(random(150,150));
  end;
  if isMillEmpty then
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 26)
  end else
  begin
    if not pickWheat then
      R_WithdrawItem(grain.ID, 10);
  end;
  sleep(random(350,150));
  R_BankScreen_Close;
  sleep(random(600,850));
  if not R_IsEquipped(chefHatID) then
  begin
    chefHatInv := R_GetInventoryItem(chefHatID);
    if length(chefHatInv) > 0 then
      Mouse.Click(chefHatinv[0].midpoint, 2, MOUSE_LEFT)
    else
      TerminateScript;
    sleep(random(600,850));
  end;
end

procedure cookFish;
var
  julietRange: RSObject;
  currentFishID, currentCookingLevel: Integer;
  timer: Timer;
begin
  julietRange := RSObject.Get(RSObjectType.GAME_OBJECT, 3238, 3409);
  if (julietRange.ref = nil) then
  begin
    writelnex("Range not found");
    julietRange.Free;
    Exit;
  end;
  player.walkTo("houseRange");
  sleep(random(500, 700));
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  while (R_CountInventoryItem(currentFishID) > 0) do
  begin
    writelnex('Using range');
    Mouse.Click(julietRange.MidPoint, MOUSE_LEFT);
    timer.Start;
    while(not R_ChatSkillOption(1)) do
    begin
      if timer.ElapsedTime >= 1000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;
    //sleep(random(1000,1100));
    writelnex("Choosing Option");
    R_ChatSkillChooseOptions(1);
    sleep(random(8000,1100));
    timer.Start;
    while (player.isAnimating) do
    begin
      if timer.ElapsedTime >= 35000 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;
  end;
  julietRange.Free;

end;

procedure withdrawCookingItems;
var
  bankBooth: RSObject;
  currentFishID, currentCookingLevel, currentFishes: Integer;
  currentFish: TRSBankItem;
begin
  currentCookingLevel := player.me.SkillLevel(7);
  if (currentCookingLevel >= 25) then
    currentFishID := rawSalmonID
  else if (currentCookingLevel >= 15) then
    currentFishID := rawTroutID
  else
    currentFishID := rawShrimpID;

  currentFishes := R_CountInventoryItem(currentFishID-2);
  fishesDone += currentFishes;

  writelnex("Opening bank");
  bankBooth := RSObject.Get(RSObjectType.GAME_OBJECT, 3254, 3419);
  if (bankBooth.ref = nil) then
  begin
    writelnex("Bank not found");
    TerminateScript;
  end;
  while not R_BankScreen do
  begin
    Mouse.Click(bankBooth.MidPoint,2, MOUSE_LEFT);
    sleep(random(2000,2500));
  end

  R_DepositAll_Items;
  writelnex('Deposited all items');
  Sleep(RandomRange(800, 900));

  currentFish := R_FindBankItem(currentFishID);

  if (currentFish.id = -1) then
  begin
    writelnex("missing cook items, TERMINATING but should do some GE");
    TerminateScript;
  end;

  //R_SetBankQuantityMode(TRSBankQuantity.ALL);
  R_WithdrawItem(currentFish.ID, 28);
  sleep(random(550,650));
  R_BankScreen_Close;
  sleep(random(600,850));
end

function StrInArray(const Value : String;const ArrayOfString : Array of String) : Boolean;
var
 Loop : String;
begin
  for Loop in ArrayOfString do
  begin
    if Value = Loop then
    begin
       Exit(true);
    end;
  end;
  result := false;
end;

Function grainsGate(enter: Boolean): Boolean;
var
  openGate, closedGate: RSObject;
  tries:    Integer;
begin
  closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
  openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
  if (openGate.ref = nil) and (closedGate.ref = nil) then
  begin
    writelnex("Grain gates not found");
    Exit(False);
  end;
  tries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering grain field');
    if player.inGrains then
    begin
      writelnex('Already inside');
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;     
    //player.WalkTo("grainEnterSpot");
    while not player.inGrains do
    begin
      if tries > 10 then
      begin    
        openGate.Free;
        closedGate.Free;
        Exit(False);
      end;
      //if player.Tile.Y >= 3457 then Break;
      while closedGate.ref <> nil do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));       
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
      end;
      //sleep(random(2000,2500) + lag);
      inc(tries);
      player.WalkTo("grainExitSpot");
    end;
  end else
  begin
    writelnex('Leaving Grain field');
    if not player.InGrains then
    begin
      writelnex('Already outside'); 
      openGate.Free;
      closedGate.Free;
      exit(True);
    end;
    player.WalkTo("grainExitSpot");
    while player.InGrains do
    begin
      if tries > 10 then Exit(False);
      //if player.Tile.Y < 3444 then Break;
      while closedGate.ref <> nil do
      begin
        Mouse.Click(closedGate.MidPoint, 2, MOUSE_LEFT);
        sleep(1000 + random(200,300));            
        closedGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3142, 3457);
        openGate := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3141, 3458);
      end;
      player.WalkTo("grainEnterSpot");
      //sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  openGate.Free;
  closedGate.Free;
  Result:=True;
end;

Function cookGuildDoor(enter: Boolean): Boolean;
var
  cookDoor: RSObject;
  tries:    Integer;
begin
  cookDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3143, 3443);
  if (cookDoor.ref = nil) then
  begin
    writelnex("CookDoor not found");
    Exit(False);
  end;
  tries := 0;
  //openCookDoor;
  if enter then
  begin
    writelnex('Entering Cooks Guild door');
    if player.InGuild then
    begin
      writelnex('Already inside');
      exit(True);
    end;
    while player.Tile <> Point(3143, 3444) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y >= 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000,2500) + lag);
      inc(tries);
    end;
  end else
  begin
    writelnex('Leaving Cooks Guild door');
    if not player.InGuild then
    begin
      writelnex('Already outside');
      exit(True);
    end;
    player.WalkTo("cookExitSpot");
    while player.Tile <> Point(3143, 3443) do
    begin
      if tries > 10 then Exit(False);
      if player.Tile.Y < 3444 then Break;
      Mouse.Click(cookDoor.MidPoint, 2, MOUSE_LEFT);
      sleep(random(2000, 2500) + lag);
      inc(tries);
    end;
  end;
  cookDoor.Free;
  Result:=True;
end;


Function rangeDoor(enter: Boolean): Boolean;
var
  rangeDoor: RSObject;
  tries:    Integer;
  rangeBox: TBox;
begin
  rangeDoor := RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412);
  tries := 0;
  rangeBox := Box(3236, 3409, 3241, 3416);
  //openCookDoor;
  if enter then
  begin
  if player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already inside');
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      exit(True);
    end;
    writelnex('Entering Range door');
    player.WalkTo("eastToHouse");
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseRange");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000,1500));
      inc(tries);
    end;
    player.WalkTo("houseRange");
    sleep(random(500, 700));
  end else
  begin
    writelnex('Leaving Range door');
    if not player.Tile.InBox(rangeBox) then
    begin
      writelnex('Already outside');
      player.WalkTo("houseToEast");
      sleep(random(1000,1500));
      exit(True);
    end;
    if (rangeDoor.ref = nil) then
    begin
      writelnex("rangeDoor is Open");
      player.WalkTo("houseToEast");
      sleep(random(500, 700));
      Exit(True);
    end;
    while (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref <> nil) do
    begin
      if tries > 10 then Exit(False);
      if (RSObject.Get(RSObjectType.BOUNDARY_OBJECT, 3242, 3412).ref = nil) then Break;
      Mouse.Click(rangeDoor.MidPoint.X + 5, rangedoor.Midpoint.y, MOUSE_LEFT);
      sleep(random(1000, 1500));
      inc(tries);
    end;
    player.WalkTo("houseToEast");
  end;
  rangeDoor.Free;
  Result:=True;
end;

Function climbStairs(direction:String): Boolean;
var
  cookStairs: RSobject;
  startingFloor: Integer;
begin
  writelnex('Climbing Stairs ' + direction);
  cookStairs := RSObject.Get(RSObjectType.GAME_OBJECT, 3144, 3447);
  if (cookStairs.ref = nil) then
  begin
    writelnex("cookStairs not found");
    Exit(False);
  end;
  startingFloor := RSClient.plane;
  Mouse.Move(cookStairs.MidPoint.X, cookStairs.MidPoint.y + 35);
  Wait(50 + RandomRange(50,100));
  Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
  Wait(50 + RandomRange(50, 100));
  R_ChooseOptions(['Climb-' + direction +' Staircase']);
  Wait(500 + RandomRange(50, 100));
  {while (startingFloor = RSClient.plane) and (tries < 10) do
  begin
    Mouse.Click(cookStairs.MidPoint, 2, MOUSE_RIGHT);
    Wait(50 + RandomRange(50, 100));
    R_ChooseOptions(['Climb-' + direction +'  Staircase']);
    Wait(500 + RandomRange(50, 100));
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;}
  cookStairs.Free;
  Result := True;
end;

Function climbToFloor(floor: Integer): Boolean;
var
  tries: Integer;
begin
  writelnex('Climbing to floor '+ inttostr(floor));
  while (RSClient.Plane <> floor) and (tries < 10)  do
  begin
    if RSClient.Plane = floor then Exit(True);
    if RSClient.Plane > floor then climbStairs("down") else climbStairs("up");
    sleep(500 + random(200, 300) + lag);
    inc(tries);
  end;
  if tries > 10 then Result:= False else Result:= True;
end;

Function emptyFlourPot:Boolean;
var
  flourPot: Array of TRSInventoryItem;
begin
  flourPot := R_GetInventoryItem(flourPotID);
  if (Length(flourPot) > 0) then
  begin
    Mouse.click(flourPot[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Pot of flour']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //flourPot.Free;
end;

Function emptyWaterBucket:Boolean;
var
  waterBucket: Array of TRSInventoryItem;
begin
  waterBucket := R_GetInventoryItem(waterBucketID);
  if (Length(waterBucket) > 0) then
  begin
    Mouse.click(waterBucket[0].MidPoint, MOUSE_RIGHT);
    sleep(random(50,100));
    R_ChooseOptions(['Empty Bucket of water']);
    sleep(random(500, 700));
    Result := (True);
  end;
  //waterBucket.Free;
end;

procedure makeFlourToPizza;
var
  hopper, hopperControl, cookMill, cookPump: RSObject;
  flourPot, waterBucket, emptyBucket: Array of TRSInventoryItem;
  i, fails, currentGrains, breakHopperCounter: Integer;
  timer: Timer;
begin         
  loginPlayer;
  writelnex('Making flourToPizza!');
  fails := 0;

  //CheckMill;
  writelnex('Checking Mill');
  cookMill := RSObject.Get(RSObjectType.GAME_OBJECT, 3140, 3449);
  if (cookMill.ref = nil) then
  begin
    writelnex("cookMill not found");
    Exit;
  end;
  //TODO check if not at cook then die
  while (R_CountInventoryItem(pizzaBaseID) < 26) do
  begin
    if not LoginPlayer then Exit;
    if (R_CountInventoryItem(grainID) < 1) then
    begin
      writelnex('Not going up because we aint got grains left');
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No flour on mill either, back to bank');
        isMillEmpty := True;
        writelnex('MILL VERTICES: ' + inttostr(Length(cookMill.Model.Vertices)));
        Break;
      end;
    end else
    begin
      emptyWaterBucket;
      emptyFlourPot;
      climbToFloor(2);

      //third floor now
      writelnex('Filling Hopper');
      hopper := RSObject.Get(RSObjectType.GAME_OBJECT, 3142, 3452);
      if (hopper.ref = nil) then
      begin
        writelnex("hopper not found");
        Exit;
      end;
      Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
      //sleep(random(5000,3500));
      timer.Start;
      while(not player.Tile.Equals(Point(3142, 3451))) do
      begin
        if timer.ElapsedTime >= 5000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper at loop zero - if this keeps happening increase lag");
            Break;
          end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);

      writelnex('Activating Hopper');
      hopperControl := RSObject.Get(RSObjectType.GAME_OBJECT, 3141, 3453);
      if (hopperControl.ref = nil) then
      begin
        writelnex("hopperControl not found");
        Exit;
      end;
      Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
      timer.Start;
      while(not player.Tile.Equals(Point(3141, 3452))) do
      begin
      if timer.ElapsedTime >= 5000 + lag then
        begin
          writeLnEx("At top floor - breaking hopperControl at loop zero - if this keeps happening increase lag");
          Break;
        end;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      sleep(random(400,600) + lag);

      currentGrains := R_CountInventoryItem(grainID);
      //TODO better check while shouldAddGrains do
      breakHopperCounter := 0;
      for i := 0 to 35 do
      begin
        if (currentGrains < 1) then
        begin
          writelnEx("At top flor - No more grains");
          Break;
        end;
        Mouse.Click(hopper.MidPoint, 2, MOUSE_LEFT);
        timer.Start;
        while(not (currentGrains <> R_CountInventoryItem(grainID))) do
        begin
          if timer.ElapsedTime >= 1000 + lag then
          begin
            writeLnEx("At top floor - breaking hopper inside loop - if this keeps happening increase lag");
            break;
          end;
          Wait(50 + Random(50));
        end;
        timer.Reset;
        sleep(random(200,300) + lag);
        //sleep(random(1000,1500));
        Mouse.Click(hopperControl.MidPoint, 2, MOUSE_LEFT);
        //R_WaitFunction(1000, 100, currentGrains <> R_CountInventoryItem(grainID));
        sleep(random(1000,1500) + lag);
        if (currentGrains = R_CountInventoryItem(grainID)) then
        begin
          WriteLnEx(inttostr(breakHopperCounter) + "/ At top floor - Hopper seems full");
          if (breakHopperCounter > 7) then Break;
          inc(breakHopperCounter);
        end;
        currentGrains := R_CountInventoryItem(grainID);
      end;

      hopper.Free;
      hopperControl.Free;

    end;
    
    //climbDown;
    writelnex('Going down');
    climbToFloor(0);
    sleep(random(300,350));
    //aca check mill antes

    player.walkTo("cookWaterSpot", True);
    timer.Start;
    while(not player.me.Tile.Equals(Point(3139, 3449))) do
    begin
      if timer.ElapsedTime >= 1800 + lag then
        Break;
      Wait(50 + Random(50));
    end;
    timer.Reset;

    //sleep(random(1500,2000));

    //CheckPump;
    writelnex('Checking Pump');
    cookPump := RSObject.Get(RSObjectType.GAME_OBJECT, 3138, 3449);
    if (cookPump.ref = nil) then
    begin
      writelnex("cookPump not found");
      Exit;
    end;

    //fill water, flour, make pizza, repeat

    while (R_CountInventoryItem(pizzaBaseID) < 26) do
    begin
      //mill failsafe

      if fails > 3 then
      begin
        fails := 0;
        writelnex('Failing too much, bye');
        Break;
      end;

      //Check if inventory full but grains left
      if (R_InventoryCount > 27) AND (R_CountInventoryItem(grainID) > 1) then
      begin
        writelnex("Inventory full but still have grains left, going upstairs");
        Break;
      end;
      //fillWater
      if (R_CountInventoryItem(potID) <= 0) then
      begin
        writelnex("No empty pot");
        //Exit;
        if not emptyFlourPot then Exit;
      end;

      emptyBucket := R_GetInventoryItem(bucketID);
      if (Length(emptyBucket) <= 0) then
      begin
        writelnex("No empty bucket");
        //Exit;
        if not emptyWaterBucket then Exit;
      end;
      sleep(random(150,200));
      Mouse.click(emptyBucket[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));

      Mouse.Click(cookPump.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(waterBucketID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      //sleep(random(1000,1000));

      //fill flour
      if (Length(cookMill.Model.Vertices) <> 316) then
      begin
        writelnex('No more flour left');
        isMillEmpty := True;
        writelnex('MILL VERTICES: ' + inttostr(Length(cookMill.Model.Vertices)));
        Break;
        inc(fails);
      end;
      Mouse.Click(cookMill.MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) > 0)) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;

      //sleep(random(1000,1500));

      //makePizza
      waterBucket := R_GetInventoryItem(waterBucketID);
      flourPot := R_GetInventoryItem(flourPotID);
      if (Length(flourPot) <= 0) or (Length(waterBucket) <= 0) then
      begin
        writelnex("MISSING flourToPizza flourPot or waterBucket ITEMS, looping to se if we can empty some");
        Break;  // change to exit
      end;

      Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
      sleep(random(50,100));
      Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
      timer.Start;
      while(not R_ChatSkillOption(3)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(1000,1100));
      writelnex("Choosing Option");
      R_ChatSkillChooseOptions(3);
      timer.Start;
      while(not (R_CountInventoryItem(flourPotID) = 0)) do
      begin
        if timer.ElapsedTime >= 1000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
      //sleep(random(500,700));
      if (R_CountInventoryItem(flourPotID) > 0) then
      begin
        writelnex('OptionFailsafe');
        Mouse.click(flourPot[0].MidPoint, MOUSE_LEFT);
        sleep(random(50,100));
        Mouse.Click(waterBucket[0].MidPoint, MOUSE_LEFT);
        sleep(random(800,900));
        R_ChatSkillChooseOptions(3);
        writelnex('Past failsafe');
        sleep(random(1500,2000));
      end

    end;
    cookPump.Free;

  end;

  writelnex('Full of pizza bases or no more flour left');
  isMillEmpty := (Length(cookMill.Model.Vertices) <> 316);
  writelnex('isMillEmpty: ' + booltostr(ismillempty));
  writelnex('MILL VERTICES: ' + inttostr(Length(cookMill.Model.Vertices)));
  cookMill.Free;
  //end floors repeat here
  //player.WalkToTileMS(Point(3143, 3446));
  //Mouse.Click(Point(6080, 6976), MOUSE_LEFT);
  //sleep(random(1000, 1500));

  //OutOfCook;
  //bank north booth 3186 3444

end;

procedure WheatProcedure;
var
  wheatObj: RSObject;
  tries, currentGrains: Integer;
  timer: Timer;
begin
  loginPlayer;
  grainsGate(true);
  if isMillEmpty then
  begin
    while (R_InventoryCount < 28)  and (tries < 50) do
    begin
      inc(tries);
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
    end;
  end else
  begin
    while (R_CountInventoryItem(GrainID) < 10) and (tries < 50) do
    begin
      inc(tries);  
      currentGrains := R_CountInventoryItem(GrainID);
      wheatObj := R_GetClosestObjectByName("Wheat", 10);
      if wheatObj.ref <> nil then
        Mouse.Click(wheatObj.MidPoint, MOUSE_LEFT);
      timer.Start;
      while (R_CountInventoryItem(GrainID) = currentGrains) do
      begin
        if timer.ElapsedTime >= 2000 + lag then
          Break;
        Wait(50 + Random(50));
      end;
      timer.Reset;
    end;
  end; 
  sleep(random(700, 1000));
  grainsGate(false);
end;

procedure grandExchange(buyGrains, sellPizzas: boolean);
begin
  if not player.inGE then Exit;
  withdrawGrandExchangeItems(buyGrains, sellPizzas);              
  if sellPizzas then sellCancelAndCollect("Pizza base", notedPizzaBaseID, currentPizzaPrice);
  if buyGrains then buyCancelAndCollect("Grain", 500, currentGrainPrice);
end;

procedure flourToPizzaProcedure;
begin
  if player.inGrains then
  begin
    writelnEx("inGrains");
    wheatProcedure;
    player.WalkTo("grainsToCook");
    sleep(random(700, 1000));
  end;
  if player.InGuild then
  begin       
    loginPlayer;
    writelnEx("InGuild");
    climbToFloor(0);
    makeFlourToPizza;
    cookGuildDoor(False);
  end else
  begin
    if (R_CountInventoryItem(grainID) > 0) and (R_CountInventoryItem(PotID) > 0) and (R_CountInventoryItem(BucketID) > 0) then
    begin
      writelnEx("NotInGuild - bankToCook");
      player.walkTo("bankToCook");
      //sleep(random(700, 1000));
      cookGuildDoor(True);
      //sleep(random(700, 1000));
    end else
    begin
      writelnEx("NotInGuild - cookToBank");
      player.walkTo("cookToBank");
      //sleep(random(700, 1000));
      if emptyWaterBucket then sleep(random(700, 1000));
      if emptyFlourPot then ;sleep(random(700, 1000));
      sleep(random(700, 1000));
      withdrawFlourToPizzaItems;
      ProgressReport;
      if (timeSinceLastGeVisit.ElapsedTime > (60 * 60 * 1000)) and useGe then
      begin      
        RInitializeTileSettings;
        RInitializeTileHeights;
        writeln('Reinitialized reflection');
        writelnEx("DOING GE");
        inc(geVisits);
        timeSinceLastGeVisit.Reset;
        timeSinceLastGeVisit.Start;
        player.WalkTo("bankToGe"); 
        sleep(random(700, 1000));
        if (grainsInBank < 2000) then
        begin
          WriteLnEx('GE: GrainsAndPizza, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(true, true);
        end else
        begin
          WriteLnEx('GE: PizzaOnly, timer is now: ' + inttostr(timeSinceLastGeVisit.ElapsedTime));
          grandExchange(false, true);
        end;
        sleep(random(700, 1000));
        player.WalkTo("geToBank");
        Exit;
      end;
      sleep(random(700, 1000));
      if pickWheat then
      begin      
        player.WalkTo("bankToGrains");
        sleep(random(700, 1000));
        wheatProcedure;  
        player.WalkTo("grainsToCook");
        sleep(random(700, 1000));
      end;
    end;
  end;
end;

procedure cookingProcedure;
begin
  rangeDoor(False);
  sleep(random(700, 1000));
  player.walkTo("bankToEast");
  sleep(random(700, 1000));
  player.walkTo("houseToEast");
  sleep(random(700, 1000));
  withdrawCookingItems;
  progressReport;
  sleep(random(700, 1000));
  player.walkTo("eastToHouse");
  sleep(random(700, 1000));
  rangeDoor(True);
  sleep(random(700, 1000));
  cookFish;
  if player.me.SkillLevel(7) >= 32 then
  begin
    writelnex("Already at 32 cooking, bye");
    progressReport;   
    rangeDoor(False);
    player.WalkTo("eastToBank");
    Exit;
  end;
end;

procedure keepAliveProcedure;
begin
  player.walkToTileMM(startPos, -10, 10);
  wait(60000 + random(5000, 30000));
end;

procedure wildProcedure;
begin
  if player.InGuild then
  begin
    writelnEx("InGuild");
    climbToFloor(0);
    cookGuildDoor(False);
  end
  player.walkto("cookToBank");
  sleep(random(700, 1000));
  withdrawWildItems;
  player.WalkTo("bankToGe");
  sleep(random(700, 1000));
  WritelnEx("Not selling pizzas, do it yourself");
  depositGrains;
  writeln('deposited');
  player.WalkTo("geToBank");
  sleep(random(700, 1000));
  player.WalkTo("bankToWild");
  sleep(random(700, 1000));
  TerminateScript;
end;

procedure hybridProcedure;
begin
  if R_InTutorialIsland then
  begin
    writelnEx("InTutIsland");
    R_TutorialIsland("");
  end;

  if player.InLumby then
  begin
    writelnEx("InLumby");
    player.walkTo("lumbyToVarrock");
  end;

  if player.InGE then
  begin
    writelnEx("InGE");
    player.walkTo("geToBank");
  end;

  if player.me.SkillLevel(7) < 32 then
  begin
    writelnex("Getting that cooking up");
    cookingProcedure;
  end else
  begin
   flourToPizzaProcedure;
  end;
end;

procedure testProcedure;
var
  obj: RSObject;  
  bmp: TMufasaBitmap;
  w, h: Int32;
begin
  writeln("testing");
  grandExchange(true, true);
  terminatescript;
end;

Function isWebActionValid(action: String): Boolean;
var
  i: Integer;
  validActions: TStringArray;
begin
  validActions := ["hybrid", "doWild", "doTest", "walkToGe", "walkToBank", "walkToWild", "pause", "buyGrains", "sellPizzas", "withdrawWildItems"];
  for i := 0 to high(validActions) do
    if validActions[i] = action then Exit(true);
end;

Function getWebPlayer: TWebPlayer;
var
  response: String;
begin
  if scriptID = "" then Exit;
  response := GetPage(actionWeb + "/enviar.php?getuserfromscript=" + scriptID);
  if response <> "" then
  begin
    Result.email := substring(response, "email:'.", ".':email");
    Result.password := substring(response, "password:'.", ".':password");
    Result.user := substring(response, "username:'.", ".':username");
    Result.action := substring(response, "action:'.", ".':action");
    Result.scriptId := substring(response, "scriptid:'.", ".':scriptid");
    Result.active := StrToBool(substring(response, "active:'.", ".':active"));
    Result.online := StrToBool(substring(response, "online:'.", ".':online"));
  end;
end;

Function getWebScript: TWebScript;
var
  response: String;
begin
  if scriptID = "" then Exit;
  response := GetPage(actionWeb + "/" + scriptID + ".txt");
  if response <> "" then
  begin
    Result.ID := strtoint(scriptID);
    Result.action := substring(response, "action:'.", ".':action");
    Result.grainPrice := strtoint(substring(response, "grainprice:'.", ".':grainprice"));
    Result.pizzaPrice := strtoint(substring(response, "pizzaprice:'.", ".':pizzaprice"));
  end;
end;

label TryAgain;

begin
  timerTrack.Start;
  timeSinceLastGeVisit.Start;
  startTime  := Now;
  pizzasDone := 0;
  floursDone := 0;
  geVisits := 0;
  pickWheat := True;
  sellPizzas := False;
  runs := 0;
  srl.Setup([]);
  Mouse.Setup();
  Sleep(50);
  ClearDebug;
  shouldRunOneOff := true;
  TryAgain:
  webPlayer := getWebPlayer;

  if (P_USERNAME <> "") and (P_PASSWORD <> "") then
  begin
    currentUser := P_USERNAME;
    currentPassword := P_PASSWORD;
  end else
  if (webPlayer.email <> "") and (webPlayer.password <> "") and (not webPlayer.online) then
    begin
      currentUser := webPlayer.email;
      currentPassword := webPlayer.password;
  end else
  begin
    Writeln("No USER set and can't get one from the site, sleeping 5 min and retrying");
    sleep(5 * 60 * 1000);
    goto TryAgain;
  end;

  while True do
  begin
    Try
      if scriptID <> "" then webScript := getWebScript;
      writeln(webScript);
      if isWebActionValid(webScript.action) then
      begin
        if action <> webScript.action then shouldRunOneOff := True;
        action := webScript.Action;
        currentGrainPrice := webScript.grainPrice;
        currentPizzaPrice := webScript.pizzaPrice;
      end else
      begin
        action := userAction; 
        currentGrainPrice := GRAIN_PRICE;
        currentPizzaPrice := PIZZA_PRICE;
      end;

      player.Free;
      progressReport;
      inc(runs);
      if not loginPlayer then goto TryAgain;
      player := RSPlayer.Me;
      startPos := player.Tile;
      player.ToggleRun(True);
      case action of
        "keepAlive": begin keepAliveProcedure end;
        "doTest":   begin testProcedure; end;
        "doWild":   begin wildProcedure; end;
        "hybrid":   begin hybridProcedure end;
        "walkToGe":   begin
                        if not shouldRunOneOff then
                        begin
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin
                          shouldRunOneOff := false;
                          if player.InLumby then
                          begin
                            writelnEx("InLumby");
                            player.walkTo("lumbyToVarrock");
                          end;

                          if player.InGuild then
                          begin
                            writelnEx("InGuild");
                            climbToFloor(0);
                            cookGuildDoor(False);
                          end;
                          player.WalkTo("cookToBank");
                          player.WalkTo("bankToGe");
                        end;
                      end;
        "walkToBank":   begin     
                        if not shouldRunOneOff then
                        begin                 
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin
                          shouldRunOneOff := false;
                          if player.InLumby then
                          begin
                            writelnEx("InLumby");
                            player.walkTo("lumbyToVarrock");
                          end;

                          if player.InGuild then
                          begin
                            writelnEx("InGuild");
                            climbToFloor(0);
                            cookGuildDoor(False);
                          end;
                          player.WalkTo("cookToBank");
                          player.WalkTo("GeToBank");
                        end;
                      end;
        "walkToWild":  begin     
                        if not shouldRunOneOff then
                        begin               
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin
                          shouldRunOneOff := false;
                          if player.InLumby then
                          begin
                            writelnEx("InLumby");
                            player.walkTo("lumbyToVarrock");
                          end;

                          if player.InGuild then
                          begin
                            writelnEx("InGuild");
                            climbToFloor(0);
                            cookGuildDoor(False);
                          end;
                          player.WalkTo("cookToBank");
                          player.WalkTo("geToBank");
                          player.WalkTo("bankToWild");
                        end;
                      end;
        "sellPizzas": begin
                        if not shouldRunOneOff then
                        begin
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin   
                          shouldRunOneOff := false;
                          grandExchange(false, true);
                        end;
                      end;
        "buyGrains": begin
                        if not shouldRunOneOff then
                        begin    
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin
                          shouldRunOneOff := false;
                          grandExchange(true, false);
                        end;
                      end;
        "withdrawWildItems": begin
                        if not shouldRunOneOff then
                        begin     
                          writeln('No new action, sleeping');
                          sleep(10* 1000);
                        end else
                        begin
                          shouldRunOneOff := false;
                          withdrawWildItems;
                        end;
                      end;
        "pause":      begin
                        writeLn("PAUSE");
                        sleep(10* 1000);
                      end;
        else
        begin
          WriteLn("NO VALID ACTION FOUND");
          TerminateScript;
        end;
      end;
    RInitializeTileSettings;
    RInitializeTileHeights;
    writeln('Reinitialized reflection');
    Except
      //E: Exception do writelnex("ERROR "+ E.message);
      writelnex('error');
      progressReport;
    end;
  end;
  player.Free;
end.
